<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>java学习笔记</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="java学习笔记">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="java学习笔记">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java学习笔记">
  
    <link rel="alternate" href="/atom.xml" title="java学习笔记" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">java学习笔记</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-JPA" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/17/JPA/" class="article-date">
  <time datetime="2019-06-17T01:40:25.000Z" itemprop="datePublished">2019-06-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/17/JPA/">JPA</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="JPA入门"><a href="#JPA入门" class="headerlink" title="JPA入门"></a>JPA入门</h1><p>ORM规范<br>    ORM：对象关系映射<br>作用:操作数据库<br>JPA是持久化规范，hibernate是其中一个实现</p>
<h2 id="JPA对比JDBC的优缺点"><a href="#JPA对比JDBC的优缺点" class="headerlink" title="JPA对比JDBC的优缺点"></a>JPA对比JDBC的优缺点</h2><p>JDBC:优点:</p>
<pre><code>   1. 操作数据库最底层，性能好控制
缺点:
   1. 使用复杂(重复代码太多)
   2. 移植数据库比较麻烦
   3. 如果要实现缓存，要自己手动去实现，性能上面没有相应的控制
   4. JDBC操作sql，jpa操作对象 
</code></pre><p>JPA:优点:</p>
<pre><code>    1. 操作简单
    2. 操作对象就相当于操作数据库
    3. 自带缓存提供
    4. 移植性比较好，只需要换一个方言
缺点:
    1. 不能干预sql语句的生成，性能不好控制 
    2. 如果一个项目对sql比较高，不适合用jpa
    3. 如果一个表中有上亿级别的数据量，不适合用jpa，也不适合用jdbc(架构使用数据库读写分离，分库分表方案解决)
</code></pre><h2 id="连接数据库的配置"><a href="#连接数据库的配置" class="headerlink" title="连接数据库的配置"></a>连接数据库的配置</h2><pre><code>四个基本配置
配置方言
shou_sql
    是否显示sql语句
让jpa自动创建相应的表
    hbm2ddl.auto
</code></pre><h2 id="自动建表"><a href="#自动建表" class="headerlink" title="自动建表"></a>自动建表</h2><pre><code>添加注解
    类上
        @Entity
            JPA就知道这里有个对象
        @Table(name=&quot;表名&quot;)
            代表对象与那张表建立关系
            可以不写，表名就是类名
    属性上
        @Id
            主键
            JPA中必须有主键
            JPA要求主键必须是serializable类型
            @GeneratedValue
                主键生成策略
                    主键
                        确定一条数据的唯一性
                            非空且唯一
                    自然主键
                        主键是有意义的
                    用代理主键
                        主键是没有意义的
                            没有意义的数据我们不需要自动填写，自动生成就行了
                                保持唯一性
                IDENTITY
                    自增策略
                        要求
                            主键必需是数字
                            数据库必需支持这个策略
                        性能高
                SEQUENCE
                    序列
                        序列对象
                        看起来还是自增
                        要求
                            主键必需是数字
                            数据库必需支持这个策略
                        性能更高
                AUTO
                    自动区分用的数据库，自动选择使用IDENTITY还是SEQUENCE
                    默认策略
                TABLE
                    表策略
                        兼容所有数据库
                        模拟序列
                        性能稍差
        @ManyToOne
            外键
                告诉JPA这里是个多对一
            fetch：抓取策略
                FetchType.EAGER
                    及时加载
                        默认
                FetchType.LAZY
                    懒(延时)加载，要用时才进行数据加载
            @JoinColum(name=&quot;外键名称&quot;)
                设置外键的名称
                子主题 2
        @Colimn（属性名=别名，length=20，unique=true，nullable=false）
            改别名
            长度改为20
            唯一
            不能为空
        @Transient
            临时属性
                数据库中不要加上
        @Lob
            longtext
        @Temporary
建表策略
    create-drop    
        删除-创建
    create
        删除-创建
    update
        没有表就创建，有表就修改
    validate
        验证你的domin和表是否对应上
</code></pre><h2 id="核心API"><a href="#核心API" class="headerlink" title="核心API"></a>核心API</h2><pre><code>Persistence
    持久化类
    创建EntityManagerFactory对象
EntityManagerFactory
    EntityManager工厂对象
    创建EntityManager对象
    特点
        重量级对象
            重
                数据源【连接池】
                二级缓存
                    导jar包
                    配置信息Second-level Cache
                    添加persistence.xml配置信息
                    二级缓存命中
                        同一个EntityManagerFactory，不同EntityManager同一个OID
                    使用场景
                        读取大于配置
                        独享控制权
                        允许出现无效数据
                        数据量不能过大
                所有jpa的配置
                预编译的SQL/JPQL
        这个对象不能随意销毁
            1:1:1--&gt;一个项目：1个EntityManagerFacttory：一个数据库
        这个对象线程安全
            线程安全影响性能
EntityManager
    操作数据库（CRUD）
        增删改必须提交事务
    方法
        merge
            添加或者修改

    特点
        轻
            连接对象
            一级缓存
                提高了查询速度
                默认提供
                一级缓存命中
                    同一个EntityManagerFactory，同一个EntityManager同一个OID
        一般来说，一个线程/一次请求 用一次EntityManager
        线程不安全
EntityTransaction
    事务对象（一组操作，要不都成功，要不都失败）
    JPA 增删改一定要有事务
</code></pre><h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><pre><code>四个状态
    临时状态（瞬时状态）
        对象刚刚创建出来还没有与entityManager发生关系
    持久化状态（托管状态）
        对象与entityManager发生关系了
            对象就存在一级缓存中，在一级缓存中的对象也就是持久化对象
        持久化的对象会不会被修改和merge方法没有关系
        只能删除持久化状态的对象
        不能修改OID
    游离状态（脱管状态）
        对象与entityManager解除了关系
            从一级缓存中移除了
    子主题 1
    删除状态
        hibernate中没有删除状态
        只要调用了remove方法，这个对象就变成删除状态，JPA就要计划把他删除了
        删除状态是一种特殊的持久化状态
            还在一级缓存中
脏数据更新
    提交数据的时候进行脏数据更新
报错
    n-to-n
        持久化对象的OID不能修改
    no session
        会话关闭后去拿取数据（懒加载）
</code></pre><h2 id="域对象-domain对象-关系"><a href="#域对象-domain对象-关系" class="headerlink" title="域对象(domain对象)关系"></a>域对象(domain对象)关系</h2><pre><code>依赖关系
    javabean之间的依赖关系
    分层:表现层,业务层,持久层(依赖关系)
    Controller表现层依赖于Service业务层，Service依赖于Dao持久层
关联关系
    类之间的引用关系，以属性定义的关系表现
    多重性
        一对一
            共享主键
            唯一外键（建议）
            默认迫切加载
        多对一
            有外键关系，外键在哪边，哪边就是多方
            先保存一方在保存多方
                性能高
            默认迫切加载
                改为懒加载
        一对多
            默认懒加载
                集合默认懒加载
        多对多
            中间表
                JoinTable
                    name
                        自定义中间表名字
                    JoinColumns
                        当前类对应的列名
                    inverseJoinColumns
                        对应关系表列名
            集合
                默认懒加载
            双向的多对多
                必须保存表名和列名都是一致的
            子主题 4
    导航性
聚合关系
    双向的多对一，一对多
        让一方放弃关系维护
            两边都在维护
            mappedBy=&quot;多方维护的字段名&quot;
        级联
            cascade=
                CascadeType.PERSIST
                    级联添加
                CascadeType.REMOVE
                    级联删除
                CascadeType.MERGE
                    级联修改
                CascadeType.ALL
                    包含级联增删改
            非常危险的操作，请慎用
                特别是级联删除
            orpherRemove
                孤儿删除
            组合关系一定要用级联
                用最强级联
            凡是单据都是组合关系
组合关系
    强聚合(整体和部分不可分割)
</code></pre><h2 id="hibernate"><a href="#hibernate" class="headerlink" title="hibernate"></a>hibernate</h2><pre><code>操作数据库的框架
    ORM框架
数据库
    关系型数据库
java语言
    面向对象的语言
是jpa的完美实现
</code></pre><h2 id="JPQL"><a href="#JPQL" class="headerlink" title="JPQL"></a>JPQL</h2><pre><code>JPA的查询语言
    面向对象
兼容各种数据库
底层是SQL
使用
    查询结果过滤
        select o from 表名 o where 
    查询排序
        子主题 1
    使用关联对象属性排序
    去重
        distinct
    size
    连接
        黄金法则
            不需要消灭笛卡尔积
            关联的是前面的对象的别名，属性
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/17/JPA/" data-id="cjx2zkphj00037otdkfy6hkrm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-maven-idea-uml" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/16/maven-idea-uml/" class="article-date">
  <time datetime="2019-06-16T01:15:41.000Z" itemprop="datePublished">2019-06-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/16/maven-idea-uml/">maven&amp;idea&amp;uml</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Maven——一个优秀的项目构建工具"><a href="#Maven——一个优秀的项目构建工具" class="headerlink" title="Maven——一个优秀的项目构建工具"></a>Maven——一个优秀的项目构建工具</h1><p>Maven项目对象模型(pom)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><pre><code>1. 自动构建(mvn jetty:run 清理,编译,测试,部署)
2. 自动导包 pom.xml中配置，先找本地仓库，如果没有，找中央仓库
3. 契约编程(代码更加规范)
</code></pre><h2 id="Maven安装"><a href="#Maven安装" class="headerlink" title="Maven安装"></a>Maven安装</h2><pre><code>1. 在需要安装的路径下解压maven
2. 配置MAVEN_HOME环境
3. 执行mvn命令 生成一个
</code></pre><h2 id="修改默认本地仓库"><a href="#修改默认本地仓库" class="headerlink" title="修改默认本地仓库"></a>修改默认本地仓库</h2><h2 id="maven命令"><a href="#maven命令" class="headerlink" title="maven命令"></a>maven命令</h2><p>mvn compile：编译(有点像javac)<br>mvn clean:清理<br>mvn clean compile:先清理，后编译<br>mvn test:测试(运行几个，失败几个，错误几个)<br>mvn package:打包<br>mvc source:jar:打源码包<br>mvn site：生成一个网站(文档)<br>mvn install:把jar包打好放到本地仓库<br>mvn eclipse:eclipse -&gt; 变成eclipse的结构<br>mvn package -Dmaven.test.skip=true -&gt; 打包的时候跳过测试</p>
<h1 id="IDEA——最好的java开发环境之一"><a href="#IDEA——最好的java开发环境之一" class="headerlink" title="IDEA——最好的java开发环境之一"></a>IDEA——最好的java开发环境之一</h1><h1 id="UML-统一建模语言"><a href="#UML-统一建模语言" class="headerlink" title="UML :统一建模语言"></a>UML :统一建模语言</h1><p>用例图:看权限的图<br>类图:类的关系(继承,多对一，一对多等，组合与聚合关系)<br>流程图:请假流程，开会流程</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/16/maven-idea-uml/" data-id="cjx2zkphv000a7otdr12iuxxs" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-EasyUI" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/13/EasyUI/" class="article-date">
  <time datetime="2019-06-13T01:17:12.000Z" itemprop="datePublished">2019-06-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/13/EasyUI/">EasyUI</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="EasyUI的认识"><a href="#EasyUI的认识" class="headerlink" title="EasyUI的认识"></a>EasyUI的认识</h2><ol>
<li>是基于JQuery的ui(界面)插件集合</li>
<li>不需要编写复杂的JavaScript，也不需要对css样式有深入了解，开发者只需要了解一些简单的html标签</li>
<li>学习方式copy+edit<h2 id="EasyUI使用"><a href="#EasyUI使用" class="headerlink" title="EasyUI使用"></a>EasyUI使用</h2></li>
</ol>
<ol>
<li>下载导入easyui文件</li>
<li><p>在对应页面引入easyui的js文件和css文件</p>
<p> &lt;%–引入easyui的样式–%&gt;<br> <link rel="stylesheet" type="text/css" href="js/easyui/themes/default/easyui.css"><br> &lt;%–引入easyui的图标–%&gt;<br> <link rel="stylesheet" type="text/css" href="js/easyui/themes/icon.css"><br> &lt;%–引入jquery的js文件–%&gt;</p>
 <script type="text/javascript" src="js/easyui/jquery.min.js"></script>
 <%--引入easyui的js文件--%>
 <script type="text/javascript" src="js/easyui/jquery.easyui.min.js"></script>
 <%--国际化--%>
 <script type="text/javascript" src="js/easyui/locale/easyui-lang-zh_CN.js"></script>
</%--国际化--%></%--引入easyui的js文件--%></li>
<li><p>使用easyui里面的组件</p>
<ol>
<li><p>直接通过标签来使用<br> 核心添加class=“easyui-组件名”</p>
<p> `&lt;div id=”p” class=”easyui-panel” title=”My Panel”</p>
<pre><code>style=&quot;width:500px;height:150px;padding:10px;background:#fafafa;&quot;
data-options=&quot;iconCls:&apos;icon-save&apos;,closable:true,
collapsible:true,minimizable:true,maximizable:true&quot;&gt;
&lt;p&gt;panel content.&lt;/p&gt;
&lt;p&gt;panel content.&lt;/p&gt;
</code></pre><p> `</p>
</li>
<li><p>通过js创建组件<br><code>&lt;div id=&quot;p&quot; style=&quot;padding:10px;&quot;&gt;
 &lt;p&gt;panel content.&lt;/p&gt;
 &lt;p&gt;panel content.&lt;/p&gt;
&lt;/div&gt;
$(&#39;#p&#39;).panel({
 width:500,
 height:150,
 title:&#39;My Panel&#39;,
 tools:[{
 iconCls:&#39;icon-add&#39;,
 handler:function(){alert(&#39;new&#39;)}
 },{
 iconCls:&#39;icon-save&#39;,
 handler:function(){alert(&#39;save&#39;)}
 }]
});</code></p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2></li>
<li>一般在创建组件的时候，就应该指定好对应属性，不然，如果创建完之后，在修改对应属性，就没有效果</li>
<li>指定属性 在 标签里面指定 ，在js代码在创建的时候，也可以指定；<h2 id="组件三要素"><a href="#组件三要素" class="headerlink" title="组件三要素"></a>组件三要素</h2></li>
</ol>
</li>
</ol>
<ol>
<li>属性:通过标签里面属性，可以让组件展示不同的效果，完成不同的功能<ol>
<li>在组建创建时都有默认属性</li>
<li>属性只能在创建(初始化)组件有效，组件创建完毕后，对某个属性修改无效</li>
<li>属性定义方式<ol>
<li>方式一:直接在标签里面写 属性=属性值</li>
<li>方式二:data-options<br> 注意一:如果在标签里面定义一个属性和在data-options里面定义同一属性，标签里面有效果<br> 注意二:有些属性只能写到data-options里面 想tools这种属性，有多个值，不能放到外面</li>
<li>方式三:直接在js中写</li>
</ol>
</li>
</ol>
</li>
<li>方法:<ol>
<li>调用方法：<br> $(“selector”).组件名(methodName,[params])</li>
<li>创建组件<br> $(“selector”).组件名（{属性键值对}）</li>
</ol>
</li>
<li><p>事件</p>
<p> //点击事件<br> onClick: function(node){</p>
<pre><code>alert(node.text);  // 在用户点击的时候提示
</code></pre><p> },</p>
</li>
</ol>
<h2 id="常用组件"><a href="#常用组件" class="headerlink" title="常用组件"></a>常用组件</h2><ol>
<li>Tabs选项卡</li>
<li>message消息提示框</li>
<li>Form表单</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/13/EasyUI/" data-id="cjx2zkphi00027otds79ddz7q" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-js高级" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/11/js高级/" class="article-date">
  <time datetime="2019-06-11T01:15:53.000Z" itemprop="datePublished">2019-06-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/11/js高级/">js高级</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="js对象"><a href="#js对象" class="headerlink" title="js对象"></a>js对象</h2><pre><code>&lt;script&gt;
    //js是一个基于对象和事件驱动编程语言
    //1.js一切皆是对象，你可以把基本类型，引用类型，函数都可以看做对象
    var num = 2.134141;
    console.debug(num.toFixed(2));//保留两位小数

    //2.js中的true和false
    var boo = false;
     if (boo){
        console.debug(&quot;不能进入&quot;)
    }
    var boo2 = new Boolean(false);
     if (boo2){
         console.debug(&quot;可以进入&quot;)
     }
     if(NaN){
         console.debug(&quot;不能进入&quot;)
     }

    //3.对象的操作
    //创建对象的方式
    var obj1 = new Object();
    var obj2 = {};
    var obj3 = new user();
    function user() {

    }
    console.debug(obj1)
    console.debug(obj2)
    console.debug(obj3)
    //给对象添加属性和方法
    obj3.name=&quot;小c&quot;;
    obj3[&quot;age&quot;]=&quot;22&quot;;
    obj3.play=function (game) {
        console.debug(this.name+&quot;玩&quot;+game)
    }
    //调用方法
    obj3.play(&quot;lol&quot;)

    //遍历对象
    for (var key in obj3){
        console.debug(key)

        //如果是方法就调用方法
        if (typeof obj3[key] == &quot;function&quot;){
            obj3[key](&quot;lol&quot;);
        }else {//是属性直接取值
            console.debug(obj3[key])
        }
    }
&lt;/script&gt;
</code></pre><h2 id="json对象和json字符串"><a href="#json对象和json字符串" class="headerlink" title="json对象和json字符串"></a>json对象和json字符串</h2><pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;../../js/jquery.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    //json字符串
    var jsonStr = &quot;{&apos;id&apos;:1,&apos;name&apos;:&apos;霸哥&apos;}&quot;;
    //json对象转换
    var jsonObj = eval(&quot;(&quot;+jsonStr+&quot;)&quot;);
    console.debug(jsonObj)

    //Json.parse()--必须是json标准格式
    //var obj=$.parseJSON(jsonStr)
    var jsonStr2 = &apos;{&quot;id&quot;:1,&quot;name&quot;:&quot;霸哥&quot;}&apos;;
    var obj=$.parseJSON(jsonStr2)
    console.debug(obj)
&lt;/script&gt;
</code></pre><h2 id="js类"><a href="#js类" class="headerlink" title="js类"></a>js类</h2><pre><code>&lt;script&gt;
    //类构造方法在写的时候，如果方法首字母是大写，一般认为是构造方法
    function Person(name,age) {
        this.name=name;
        this.age=age;
    }

    //属性拷贝
    //方式2 一个一个拷贝
    var obj1 = {
        name:&quot;gg&quot;,
        age:&quot;18&quot;
    }
    var obj2 = {
    }
    obj2.name=obj1.name;
    obj2.age=obj1.age;
    console.debug(obj2)
    //方式3 循环对象
    for (var key in obj1){
        if (!obj2.hasOwnProperty(key)){//判断里面是否有属性
            obj2[key]=obj1[key];
        }
    }
    console.debug(obj2)
&lt;/script&gt;
</code></pre><h2 id="js的prototype"><a href="#js的prototype" class="headerlink" title="js的prototype"></a>js的prototype</h2><pre><code>&lt;script&gt;
    //prototype:原型的意思--js对象都有prototype属性，使你可以向对象添加属性和方法
    //使用
    /**
     * 对象组成 ：自定义属性
     *             原型属性
     *      先从自定义属性对象中找，找不到到原型里面找
     */
    function User(name,age) {
        this.name=name;
        this.age=age;
    }
    var user1=new User(&quot;彩旗&quot;,23)
    var user2=new User(&quot;天霸&quot;,23)
    //展示目录结构
    console.dir(user1)
    console.dir(user2)
    //对象里面的原型属性__proto__ ，对象里面原型属性是相同或者共享
    console.debug(user1.__proto__ === user2.__proto__)
    //原型上面定义方法
    User.prototype.eat=function (food) {
        console.debug(this.name+&quot;吃&quot;+food)
    }
&lt;/script&gt;
</code></pre><h2 id="js中的回调函数"><a href="#js中的回调函数" class="headerlink" title="js中的回调函数"></a>js中的回调函数</h2><pre><code>&lt;script&gt;
    //函数：方法 实现一块逻辑，一堆代码打包成一个方法
    //普通函数:function user(){}
    //构造函数:function User(){}
    //回调函数:函数作为一个参数，传递给另一个函数，重新回调这个函数
    setTimeout(test,3000);//异步
    function test() {
        console.debug(111)
    }
    console.debug(222)
    //匿名函数:没有名字的函数
    // 作用：1,如果变量只用一次的时候 可以放到匿名函数中  解决作用域污染问题
    //       2，作为参数传递
    (function (a,b) {
        var result=a+b;
        //window.result=result;暴露到window中
    })(7,7);
&lt;/script&gt;
</code></pre><h2 id="jquery事件委托"><a href="#jquery事件委托" class="headerlink" title="jquery事件委托"></a>jquery事件委托</h2><pre><code>&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
&lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;title&gt;Title&lt;/title&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;../../js/jquery.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    //事件委托:给动态元素添加事件

    //绑定事件
    $(function () {
        $(&quot;#add&quot;).click(function () {
            var content = &quot;&lt;div&gt;\n&quot; +
                &quot;        附件:&lt;input type=\&quot;file\&quot; name=\&quot;file\&quot;&gt;\n&quot; +
                &quot;        &lt;a class=\&quot;delete\&quot; href=\&quot;javascript:;\&quot;&gt;删除&lt;/a&gt;\n&quot; +
                &quot;        &lt;a class=\&quot;examine\&quot; href=\&quot;javascript:;\&quot;&gt;查看&lt;/a&gt;\n&quot; +
                &quot;    &lt;/div&gt;&quot;;
            $(&quot;#userForm&quot;).append(content);
        })
        //事件委托
        $(&quot;#userForm&quot;).on(&apos;click&apos;,&apos;.delete&apos;,function () {
            console.debug(&quot;删除&quot;)
        })
    })

&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;a id=&quot;add&quot; href=&quot;javascript:;&quot;&gt;添加&lt;/a&gt;
&lt;form id=&quot;userForm&quot;&gt;
&lt;div&gt;
    附件:&lt;input type=&quot;file&quot; name=&quot;file&quot;&gt;
&lt;/div&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h2 id="js的闭包"><a href="#js的闭包" class="headerlink" title="js的闭包"></a>js的闭包</h2><pre><code>&lt;script&gt;
    //闭包：函数内使用函数外的变量
    var a=10;
    function b() {
        alert(a)
    }
    //闭包案例--计数案例
    var  result=0;
    function getSum() {
        return result++;
    }
    console.debug(getSum());
    console.debug(getSum());
    result=0;
    console.debug(getSum())

    //使用闭包和匿名函数结合起来使用
    (function () {
        var result1=0;
        window.getSum1=function () {
            result1++;
            return result1;
        }
    })();
    console.debug(getSum1());
    console.debug(getSum1());
    //result1=10;
    console.debug(getSum1());
&lt;/script&gt;
</code></pre><h2 id="js里面的this用法"><a href="#js里面的this用法" class="headerlink" title="js里面的this用法"></a>js里面的this用法</h2><p>this的指向的改变</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/11/js高级/" data-id="cjx2zkphs00087otdfby8hgkc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-jQuery" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/10/jQuery/" class="article-date">
  <time datetime="2019-06-10T01:14:35.000Z" itemprop="datePublished">2019-06-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/10/jQuery/">jQuery</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="jQuery——write-less-do-more"><a href="#jQuery——write-less-do-more" class="headerlink" title="jQuery——write less do more"></a>jQuery——write less do more</h1><p>jQuery:优秀的js框架</p>
<h2 id="jQuery的使用"><a href="#jQuery的使用" class="headerlink" title="jQuery的使用"></a>jQuery的使用</h2><ol>
<li>引入jquery文件<br> <code>&lt;script type=&quot;text/javascript&quot; src=&quot;/js/jquery.min.js&quot;&gt;&lt;/script&gt;</code></li>
<li><p>页面加载事件</p>
<pre><code>//页面加载完之后再执行代码，先于window.onload执行
$(function(){

})
</code></pre></li>
<li>jquery中$和jQuery<br> $ === jQuery<br> 如果其他框架里面也使用了$符号，就使用jQuery的写法</li>
<li><p>DOM对象和jquery对象的转换</p>
<pre><code>$(function(){
    //dom对象
    var domObj = document.getElementById(&quot;mySpan&quot;);

    //jquery对象
    var jqueryObj = $(&quot;#mySpan&quot;);

    //有时候需要把dom对象转成jquery对象--可以调用jquery里面的方法
    var domToJquery = $(domObj);

    //有时候需要把jquery对象转成dom对象--可以使用dom原生的属性和方法
    var jqueryToDom = jqueryObj[0];
})
</code></pre></li>
<li><p>选择器</p>
<pre><code>//id选择器 id一般不重复
$(&quot;#id&quot;);

//class选择器
$(&quot;.class&quot;);

//标签选择器 页面上的所有标签都有效果
$(&quot;div&quot;);

//获取所有元素--没什么用
$(&quot;*&quot;);

//多元素选择器
$(&quot;div,span&quot;)

//层次选择器
//祖先后代
$(&quot;div span&quot;)
//父亲儿子
$(&quot;div &gt; span&quot;)
//相邻选择器
$(&quot;input + input&quot;)
//同级选择器
$(&quot;form ~ input&quot;)

//属性选择器
</code></pre></li>
<li><p>jquery注册事件方式<br> //方式一注册事件<br> $(“#id”).click(function(){<br> })</p>
<p> //方式二注册事件<br> $(“#id”).on(‘click’,function(){<br> })<br> //取消事件<br> $(“#id”).off(‘click’)</p>
<p> //方式三注册事件<br> $(“#id”).bind(‘click’,function(){<br> })<br> //取消事件<br> $(“#id”).unbind(‘click’);</p>
</li>
<li>jquery常用方法</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/10/jQuery/" data-id="cjx2zkphr00077otdisha1rue" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-AJAX" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/09/AJAX/" class="article-date">
  <time datetime="2019-06-09T01:12:45.000Z" itemprop="datePublished">2019-06-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/09/AJAX/">AJAX</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="js"><a href="#js" class="headerlink" title="js"></a>js</h2><h3 id="js的引入方式"><a href="#js的引入方式" class="headerlink" title="js的引入方式"></a>js的引入方式</h3><ol>
<li>直接在行内标签内使用</li>
<li>在<script>标签内使用</li>
<li>外部js引入<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3></li>
<li>如果引入外部js文件，就不要再这个标签内写内容</li>
<li><script>标签引入文件不能使用单标签</li>
<li>js加载顺序是从上往下</li>
<li><p><a herf="#">点击</a>存在锚点效果</p>
<h3 id="js里面的函数"><a href="#js里面的函数" class="headerlink" title="js里面的函数"></a>js里面的函数</h3><p>什么是函数：函数就是方法，function<br>函数的定义<br> function say(name,food){</p>
<p> }<br>函数调用<br> 调用方法，参数可以多，如果参数传少了，默认值是undefined666<br> say();<br> window.say();<br>动态调用<br> window<a href="">“say”</a>;<br>js中一切皆对象，函数也是对象</p>
</li>
</ol>
<p>函数返回值<br>    如果方法没有返回值，返回undefined</p>
<p>java 方法重载：方法名相同，参数列表不同，和返回值无关<br>js没有重载一说，方法名相同，后面的方法会覆盖前面的方法</p>
<h3 id="js引擎执行过程"><a href="#js引擎执行过程" class="headerlink" title="js引擎执行过程"></a>js引擎执行过程</h3><p>js变量提升</p>
<h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><p>ajax即Asynchronous JavaScript And XML<br>异步JavaScript和XML，是指一种创建交互式网页应用的网页开发技术<br>异步JavaScript：浏览器处理事情，如果没有处理完，可以做其他事情<br>XML：可拓展性标记语言<br>局部刷新技术，是前端技术，属于js里面的内容</p>
<h3 id="获取服务器时间"><a href="#获取服务器时间" class="headerlink" title="获取服务器时间"></a>获取服务器时间</h3><h2 id="json"><a href="#json" class="headerlink" title="json"></a>json</h2><p>json:JavaScript Object Notation<br>一种轻量级的数据交换格式</p>
</script></li></ol>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/09/AJAX/" data-id="cjx2zkphc00007otdvwz9125i" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JavaScript" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/09/JavaScript/" class="article-date">
  <time datetime="2019-06-09T01:12:33.000Z" itemprop="datePublished">2019-06-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/09/JavaScript/">JavaScript</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/09/JavaScript/" data-id="cjx2zkphq00067otdqkrm06y4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-缓存" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/06/缓存/" class="article-date">
  <time datetime="2019-06-06T06:05:03.000Z" itemprop="datePublished">2019-06-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/06/缓存/">缓存</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-缓存-cache"><a href="#1-缓存-cache" class="headerlink" title="1.缓存(cache)"></a>1.缓存(cache)</h2><p>缓存是指可以进行高数数据交换的存储器,也就是一个容器，底层是Map，存在内存里面,不是存在磁盘里面，内存数据肯定要比磁盘数据快,有些缓存可以存储在内存，也可以存储在磁盘里面</p>
<h2 id="2-缓存有什么用"><a href="#2-缓存有什么用" class="headerlink" title="2.缓存有什么用"></a>2.缓存有什么用</h2><p>提高查询的效率，减轻服务器压力<br>用空间换时间概念</p>
<h2 id="3-缓存雪崩"><a href="#3-缓存雪崩" class="headerlink" title="3.缓存雪崩"></a>3.缓存雪崩</h2><p>缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机<br>解决方案：<br>         1.缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。<br>         2.如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。<br>         3.设置热点数据永远不过期。</p>
<h2 id="4-缓存穿透"><a href="#4-缓存穿透" class="headerlink" title="4.缓存穿透"></a>4.缓存穿透</h2><p>缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。<br>解决方案：<br>         1.接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截；<br>         2.从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击</p>
<h2 id="5-缓存击穿"><a href="#5-缓存击穿" class="headerlink" title="5.缓存击穿"></a>5.缓存击穿</h2><p> 缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力<br>解决方案：<br>         1.设置热点数据永远不过期。<br>         2.加互斥锁</p>
<p>缓存框架：<br>    EhCache：<br>        特点:1.快速<br>             2.简单</p>
<pre><code>         3.    
Memcached：只支持简单的key/value数据结构
</code></pre><h2 id="6-缓存的操作"><a href="#6-缓存的操作" class="headerlink" title="6.缓存的操作"></a>6.缓存的操作</h2><pre><code>CacheManager 缓存对象
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/06/缓存/" data-id="cjx2zkphu00097otdmbe8xdxr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-freemaker入门demo" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/04/freemaker入门demo/" class="article-date">
  <time datetime="2019-06-04T01:29:07.000Z" itemprop="datePublished">2019-06-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/04/freemaker入门demo/">freemaker入门demo</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>FreeMarker是一款模板引擎： 即一种基于模板和要改变的数据，    并用来生成输出文本（HTML网页、电子邮件、配置文件、源代码等）的通用工具<br>FreeMarker是免费的，基于Apache许可证2.0版本发布。<br>FreeMarker原理：模板+数据==&gt;数据</p>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h3 id="1-pom文件添加jar包"><a href="#1-pom文件添加jar包" class="headerlink" title="1.pom文件添加jar包"></a>1.pom文件添加jar包</h3><pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.freemarker&lt;/groupId&gt;
    &lt;artifactId&gt;freemarker&lt;/artifactId&gt;
    &lt;version&gt;2.3.28&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><h3 id="2-创建数据对象"><a href="#2-创建数据对象" class="headerlink" title="2.创建数据对象"></a>2.创建数据对象</h3><h3 id="2-创建模板"><a href="#2-创建模板" class="headerlink" title="2.创建模板"></a>2.创建模板</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/04/freemaker入门demo/" data-id="cjx2zkphp00057otdl3eufdyd" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-CMS招聘网站" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/31/CMS招聘网站/" class="article-date">
  <time datetime="2019-05-31T01:13:21.000Z" itemprop="datePublished">2019-05-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/31/CMS招聘网站/">CMS招聘网站</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>CMS：CMS是”Content Management System”的缩写，意为”内容管理系统”。</p>
<h1 id="一-环境搭建"><a href="#一-环境搭建" class="headerlink" title="一 环境搭建"></a>一 环境搭建</h1><p>Maven+spring+springMVC+springJDBC+mysql+Tomcat+bootstrap+jsp+jQuery</p>
<h2 id="1-创建maven项目"><a href="#1-创建maven项目" class="headerlink" title="1.创建maven项目"></a>1.创建maven项目</h2><h2 id="2-创建数据库"><a href="#2-创建数据库" class="headerlink" title="2.创建数据库"></a>2.创建数据库</h2><h2 id="3-导包"><a href="#3-导包" class="headerlink" title="3.导包"></a>3.导包</h2><h2 id="4-配置文件"><a href="#4-配置文件" class="headerlink" title="4.配置文件"></a>4.配置文件</h2><h1 id="二-轮播模块"><a href="#二-轮播模块" class="headerlink" title="二 轮播模块"></a>二 轮播模块</h1><h2 id="1-建表"><a href="#1-建表" class="headerlink" title="1.建表"></a>1.建表</h2><pre><code>//id
private Long id;
//路径
private String storepath;
//简述
private String intro;
//是否启用
private boolean isenabled;
//时间
private Date inputdate = new Date();
</code></pre><h2 id="富文本编辑器"><a href="#富文本编辑器" class="headerlink" title="富文本编辑器"></a>富文本编辑器</h2><p>富文本框回显：<code>&lt;c:out value=&quot;${jobOne.describes}&quot; escapeXml=&quot;false&quot;/&gt;</code>加到div标签里面</p>
<pre><code>&lt;c:out value=&quot;${picOne.intro}&quot; escapeXml=&quot;false&quot;/&gt;
</code></pre><h2 id="真分页-后端分页"><a href="#真分页-后端分页" class="headerlink" title="真分页(后端分页)"></a>真分页(后端分页)</h2><p>好处：占用内存小<br>劣势：翻页慢<br>它查询数据是匀速的<br>代码实现：<br>domain：</p>
<pre><code>private int currentPage;//当前页
private int pageSize;//每页显示多少条
private int recordCount;//总记录数
private List recordList;//本页的数据列表
private int pageCount;//总页数
private int prePage;//上一页
private int nextPage;//下一页
private int firstPage;//首页
private int endPage;//尾页
/**
 * 只接受前4个必要的属性，会自动计算出其他3个属性的值
 * @param currentPage
 * @param pageSize
 * @param recordCount
 * @param recordList
 */
public PageBean(int currentPage, int pageSize, int recordCount,List recordList) {
    this.firstPage=1;
    this.currentPage = currentPage;
    this.pageSize = pageSize;
    this.recordCount = recordCount;
    this.recordList = recordList;
    //计算总页码
    pageCount = (recordCount + pageSize - 1) / pageSize;
    this.endPage=pageCount;
    this.prePage=currentPage==1?1:currentPage-1;
    this.nextPage=currentPage==endPage?endPage:currentPage+1;
}
</code></pre><p>Condition：</p>
<pre><code>private int pageNum = 1;// 当前页
private int pageSize = 5;// 每页显示多少条记录
</code></pre><p>Dao：</p>
<pre><code>//分页查询
public PageBean getPageBean(Condition condition) {
    int pageNum = condition.getPageNum();
    int pageSize = condition.getPageSize();
    // 查询列表
    String sql=&quot;SELECT * FROM pic limit ?,?&quot;;
    List&lt;Pic&gt; list = jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;&gt;(Pic.class), (pageNum - 1) * pageSize, pageNum * pageSize);
    // 查询总记录数量
    String sql2=&quot;SELECT COUNT(*) FROM pic t&quot;;
    int aLong = jdbcTemplate.queryForObject(sql2, int.class);
    return new PageBean(pageNum, pageSize,aLong, list);
}
</code></pre><p>controller:</p>
<pre><code>//分页查询
@RequestMapping(&quot;/list&quot;)
public String list(Model model,Condition condition) {
    PageBean pageBean = picService.getPageBean(condition);
    model.addAttribute(&quot;pageList&quot;,pageBean );
    return &quot;main&quot;;
}
</code></pre><p>前端JSP页面:</p>
<pre><code>&lt;!--分页--&gt;
&lt;nav class=&quot;navbar-right&quot;&gt;
&lt;ul class=&quot;pagination&quot; id=&quot;paging&quot;&gt;
    &lt;li&gt;
        &lt;span&gt;当前第${pageList.currentPage}页&lt;/span&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;a href=&quot;/pic/list?pageNum=${pageList.firstPage}&quot;&gt;
            &lt;span aria-hidden=&quot;true&quot;&gt;首页&lt;/span&gt;
        &lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;a href=&quot;/pic/list?pageNum=${pageList.prePage}&quot; aria-label=&quot;上一页&quot;&gt;
            &lt;span aria-hidden=&quot;true&quot;&gt;上一页&lt;/span&gt;
        &lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;a href=&quot;/pic/list?pageNum=${pageList.nextPage}&quot; aria-label=&quot;下一页&quot;&gt;
            &lt;span aria-hidden=&quot;true&quot;&gt;下一页&lt;/span&gt;
        &lt;/a&gt;
    &lt;/li&gt;

    &lt;li&gt;
        &lt;a href=&quot;/pic/list?pageNum=${pageList.endPage}&quot; aria-label=&quot;尾页&quot;&gt;
            &lt;span aria-hidden=&quot;true&quot;&gt;尾页&lt;/span&gt;
        &lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;span&gt;总页数：共${pageList.pageCount}页&lt;/span&gt;
        &lt;span&gt;总数据：共${pageList.recordCount}条&lt;/span&gt;
    &lt;/li&gt;
&lt;/ul&gt;
</code></pre><p></p>
<h1 id="职位模块"><a href="#职位模块" class="headerlink" title="职位模块"></a>职位模块</h1><h2 id="1-建表-1"><a href="#1-建表-1" class="headerlink" title="1.建表"></a>1.建表</h2><p>职位表</p>
<pre><code>private Long id;//id
private String title;//工作职位
private Integer addrId;//地点
private Integer jobnum;//招聘人数
private Integer treatment;//薪水
private String describes;//职位描述
private String requires;//职位要求
private Integer positiontype;
private Integer isenabled;//是否启用前台展示
private Date inputdate=new Date();//发布时间
private String htmlurl;//展示页面地址
</code></pre><h2 id="职位的查询展示"><a href="#职位的查询展示" class="headerlink" title="职位的查询展示"></a>职位的查询展示</h2><h2 id="职位的新增操作"><a href="#职位的新增操作" class="headerlink" title="职位的新增操作"></a>职位的新增操作</h2><h2 id="新增职位产生静态化页面"><a href="#新增职位产生静态化页面" class="headerlink" title="新增职位产生静态化页面"></a>新增职位产生静态化页面</h2><p>新增职位根据模板生成职位详情页面<br>目的:提高运行速度,减轻服务器负担。<br>模板技术：freemaker</p>
<p>1.创建模板detail.ftl</p>
<h2 id="高级查询"><a href="#高级查询" class="headerlink" title="高级查询"></a>高级查询</h2><p>高级查询：多个条件组合起来进行查询<br>高级查询核心：根据条件拼接成不同的SQL进行查询</p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>ehcache：快速精干的java级别的缓存框架<br>思路：<br>查询的时候先到缓存中查询数据，如果有，直接返回，如果没有，在查询数据库，再放入缓存<br>新增、修改数据缓存里面的数据需要同步修改<br>删除数据时删除缓存中的数据</p>
<h3 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h3><p><code>&lt;!--缓存--&gt;
    &lt;!-- https://mvnrepository.com/artifact/net.sf.ehcache/ehcache --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt;
      &lt;artifactId&gt;ehcache&lt;/artifactId&gt;
      &lt;version&gt;2.6.11&lt;/version&gt;
      &lt;type&gt;pom&lt;/type&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
         &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
       &lt;artifactId&gt;slf4j-nop&lt;/artifactId&gt;
       &lt;version&gt;1.7.2&lt;/version&gt;
    &lt;/dependency&gt;</code></p>
<h3 id="写一个缓存工具类"><a href="#写一个缓存工具类" class="headerlink" title="写一个缓存工具类"></a>写一个缓存工具类</h3><p>`public class CacheUtils {<br>    /**</p>
<pre><code> * 缓存存放方法
 * @param key
 * @param value
 * @param cacheManager 操作缓存的对象
 * @param cacheName 缓存名称
 */
public static void putCache(Object key, Object value, CacheManager cacheManager, String cacheName){
    //获取缓存对象
    Cache cache = cacheManager.getCache(cacheName);
    //往缓存对象存值
    Element element = new Element(key,value);
    //把element放入缓存
    cache.put(element);
}
//从缓存里面取值
public static Element getCache(Object key,CacheManager cacheManager, String cacheName){
    Cache cache = cacheManager.getCache(cacheName);
    Element element = cache.get(key);
    return element;
}
//删除缓存
public static void delCache(CacheManager cacheManager, String cacheName){
    Cache cache = cacheManager.getCache(cacheName);
    cache.removeAll();
}
</code></pre><p>}`</p>
<h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><pre><code>//查询
@Override
public PageBean getPageBean(Condition condition) {
    PageBean pageBean = null;
    String key= &quot;pageKey&quot;+condition.getPageNum();
    //获取缓存数据
    Element element = CacheUtils.getCache(key, cacheManager, Constants.CACHE_NAME);
    if (element==null){//如果数据为空从数据库查询数据存入缓存中
        pageBean= JobDao.getPageBean(condition);
        CacheUtils.putCache(key,pageBean ,cacheManager , Constants.CACHE_NAME);
        System.out.println(CacheUtils.getCache(key,cacheManager ,Constants.CACHE_NAME ));
    }else {//数据不为空直接返回缓存中的数据
        pageBean= (PageBean) element.getObjectValue();
    }
    return pageBean;
}
</code></pre><h2 id="springMVC拦截器"><a href="#springMVC拦截器" class="headerlink" title="springMVC拦截器"></a>springMVC拦截器</h2><p>访问controller时拦截器拦截处理<br>定义一个拦截器，实现HandlerInterceptor接口</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/05/31/CMS招聘网站/" data-id="cjx2zkphh00017otdskvnfx5o" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/06/17/JPA/">JPA</a>
          </li>
        
          <li>
            <a href="/2019/06/16/maven-idea-uml/">maven&amp;idea&amp;uml</a>
          </li>
        
          <li>
            <a href="/2019/06/13/EasyUI/">EasyUI</a>
          </li>
        
          <li>
            <a href="/2019/06/11/js高级/">js高级</a>
          </li>
        
          <li>
            <a href="/2019/06/10/jQuery/">jQuery</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 sunlei<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>