<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>java学习笔记</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="java学习笔记">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="java学习笔记">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java学习笔记">
  
    <link rel="alternate" href="/atom.xml" title="java学习笔记" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">java学习笔记</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-面试题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/14/面试题/" class="article-date">
  <time datetime="2019-07-14T01:02:57.000Z" itemprop="datePublished">2019-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/14/面试题/">面试题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li>forword和redirect的区别以及各自的应用场景<br> forword请求转发，redirect重定向<br> 区别：<pre><code>1. forward是一个请求的延续，可以共享request的数据，redirect开启一个新的请求，不可以共享request
2. forward地址栏不发生变化，redirect地址栏发生变化
3. forward是发送一次请求，redirect是发送两次请求
4. forward不能跨域访问，redirect能跨域访问
5. forward请求能访问WEB-inf下main的资源
</code></pre> 应用场景<br> forward一般用于用户登录的时候，根据角色转发到相应的模块<br> redirect一般用于用户注销登录时返回主页面和跳转到其他的网站等</li>
<li>为什么要进行事务管理,Spring是如何进行事务管理支持的<br> 防止出现脏数据，防止数据库数据出现问题<br> spring是通过“声明式事务(基于AOP)”的方式对事务进行管理，即在配置文件中进行声明</li>
<li>解释一下DI依赖注入和IOC控制反转，Spring中是如何做的</li>
<li>Spring中的BeanFactory与ApplicationContext的区别</li>
<li>什么是aop，aop的作用是什么</li>
<li>GET与POST的区别，分别用在什么场景合适？</li>
<li>什么是单例模式，有哪些实现方式，写出其中两种</li>
<li>数据库储存引擎myisam / innodb的区别</li>
<li>模糊查询可以使用索引吗？</li>
<li>索引的优缺点</li>
<li>介绍一下hibernate的缓存机制</li>
<li>请描述一下springMvc执行流程<ol>
<li>客户端发送请求通过springMVC的核心控制器</li>
</ol>
</li>
<li>Servlet的生命周期</li>
<li>Jsp九大内置对象</li>
<li>自我介绍</li>
<li>请谈谈你最近做的一个项目</li>
<li>你主要负责的模块有哪些</li>
<li>Sleep与wait的区别</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/14/面试题/" data-id="cjy2n9fpe000dhwtdlxpi5nyn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-（Spring+SpringDataJPA+SpringMVC+EasyUI+Maven)-智能商贸" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/27/（Spring+SpringDataJPA+SpringMVC+EasyUI+Maven)-智能商贸/" class="article-date">
  <time datetime="2019-06-27T01:21:28.000Z" itemprop="datePublished">2019-06-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/27/（Spring+SpringDataJPA+SpringMVC+EasyUI+Maven)-智能商贸/">(Spring+SpringDataJPA+SpringMVC+EasyUI+Maven)-智能商贸</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h1><ol>
<li>这个项目是干什么的</li>
<li>项目用到哪些技术<br> spring+springMVC+springDataJpa+shiro+easypoi+maven+hightchart+idea</li>
<li><p>模块</p>
<ol>
<li>基础模块(用户管理，产品模块，数据字典，客户管理…)</li>
<li>权限模块(shiro)</li>
<li>登录模块(第三方登录，自动登录，限制登录人数，手机登录，忘记密码…)</li>
<li>采购模块</li>
<li>报表模块(多张表进行连表查询最终做的统计)</li>
<li>库存模块<h1 id="SpringDataJpa"><a href="#SpringDataJpa" class="headerlink" title="SpringDataJpa"></a>SpringDataJpa</h1>spring在jpa基础上又做了一层封装让你做crud更加简单<h1 id="sssdj的集成步骤"><a href="#sssdj的集成步骤" class="headerlink" title="sssdj的集成步骤"></a>sssdj的集成步骤</h1></li>
<li>创建web项目</li>
<li>导入相应的jar包</li>
<li>配置ApplicationContext.xml文件<ol>
<li>编写jdbc.properties</li>
<li>DataSource</li>
<li>EntityManagerFactory<ol>
<li>依赖dataSource</li>
<li>扫描domain包</li>
<li>具体实现的框架<br> 方言<br> 是否显示sql<br> 建表策略</li>
</ol>
</li>
</ol>
</li>
<li>springMvc的核心配置<ol>
<li>扫描controller包</li>
<li>开启springMvc注解支持</li>
<li>静态资源放行</li>
<li>视图解析器</li>
</ol>
</li>
<li>web.xml<ol>
<li>启动spring容器</li>
<li>启动springMvc容器</li>
<li>解决post提交乱码问题<h1 id="完成domain层"><a href="#完成domain层" class="headerlink" title="完成domain层"></a>完成domain层</h1><h1 id="Velocity模板技术"><a href="#Velocity模板技术" class="headerlink" title="Velocity模板技术"></a>Velocity模板技术</h1><h2 id="EasyCode"><a href="#EasyCode" class="headerlink" title="EasyCode"></a>EasyCode</h2>EasyCode是基于IntelliJ IDEA Ultimate版开发的一个代码生成插件，主要通过自定义模板（基于velocity）来生成各种你想要的代码。通常用于生成Entity、Dao、Service、Controller。如果你动手能力强还可以用于生成HTML、JS、PHP等代码。理论上来说只要是与数据有关的代码都是可以生成的。<h1 id="shiro"><a href="#shiro" class="headerlink" title="shiro"></a>shiro</h1>shiro：shiro是一个强大易用的java安全框架<br>常见的权限框架</li>
</ol>
</li>
<li>spring security<ol>
<li>是spring公司的产品，它功能非常强大，属于重量级框架，提供的API文档非常丰富</li>
</ol>
</li>
<li>shiro<ol>
<li>是Apache公司的产品，属于轻量级框架<br>shiro四大核心</li>
</ol>
</li>
<li>身份认证：登录</li>
<li>授权：给当前登录人，授予角色和权限</li>
<li>密码学：指的就是对你的密码进行加密</li>
<li>session管理：shiro提供的session功能非常强大，不仅可以用于Bs架构还可以用于Cs架构，如果你把数据存储到shiro的session中它会自动同步到你的HttpSession中，shiro还可以对session进行crud<br>使用shiro</li>
<li>导入jar包<!-- shiro的支持包 -->
<dependency><br><groupid>org.apache.shiro</groupid><br><artifactid>shiro-all</artifactid><br><version>1.4.0</version><br><type>pom</type><br></dependency><br><!-- shiro与Spring的集成包 --><br><dependency><br><groupid>org.apache.shiro</groupid><br><artifactid>shiro-spring</artifactid><br><version>1.4.0</version><br></dependency></li>
<li><p>创建shiro配置<br> &lt;?xml version=”1.0” encoding=”UTF-8”?&gt;</p>
<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"><br><!--shiro的核心对象--><br><bean id="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager"><br> <property name="realm" ref="itsourceRealm"><br></property></bean><br><!--自定义realm--><br><bean id="itsourceRealm" class="com.sunlei.aisell.realm.ItsourceRealm"><br> <property name="credentialsMatcher"><br>     <bean class="org.apache.shiro.authc.credential.HashedCredentialsMatcher"><br>         <property name="hashAlgorithmName" value="MD5"><br>         <property name="hashIterations" value="10"><br>     </property></property></bean><br> </property><br></bean><br><!--
 处理    代理过滤器拦截的所有请求
 注意事项:该bean的id必须要和代理过滤器的name一致,否则报错
--><br><bean id="shiroFilter" class="org.apache.shiro.spring.web.ShiroFilterFactoryBean"><br> <property name="securityManager" ref="securityManager"><br> <!-- 如果你的请求,没有认证或者没有认证通过,或者注销之后,都跳转到loginUrl对应的请求中--><br> <property name="loginUrl" value="/s/login.jsp"><br> <!--登录成功之后,跳转到successUrl对应的路径中--><br> <property name="successUrl" value="/s/index"><br><br> <!--没有权限都跳转到unauthorizedUrl对应的路径中--><br> <property name="unauthorizedUrl" value="/s/unauthorized.jsp"><br><br> <!--过滤器链的定义--><br> <property name="filterChainDefinitions"><br>     <value><br>         <!--直接放行不进行拦截--><br>         /s/login.jsp = anon<br>         /login=anon<br>         /logout=logout<br>         /dept/index=perms[“dept:index”]<br>         /dept/save=perms[“dept:save”]<br>         /dept/delete=perms[“dept:delete”]<br>         /dept/update=perms[“dept:update”]<br>         /permission/index=perms[“permission:index”]<br>         <!--
         /*与/**的区别:
                  /* 表示拦截所有的请求,你的请求只能拦截一级,多级无法拦截
                  /**:表示拦截所有的请求,你的请求1级或者多级都可以正常拦截
                authc:认证通过之后才能放行
                anon:匿名过滤器,直接放行
                logout:注销
          --><br>         /** = authc<br>     </value><br> </property><br></property></property></property></property></bean><br></beans></li>
<li>自定义realm</li>
<li>创建MD5工具类</li>
</ol>
</li>
</ol>
<pre><code>3. 集成spring

shiroMD5加密        

    登录时用密码匹配器
</code></pre><h1 id="java操作办公软件：word-ppt-excel-pdf"><a href="#java操作办公软件：word-ppt-excel-pdf" class="headerlink" title="java操作办公软件：word ppt excel pdf"></a>java操作办公软件：word ppt excel pdf</h1><p>easypoi</p>
<h1 id="数据字典"><a href="#数据字典" class="headerlink" title="数据字典"></a>数据字典</h1><p>简单理解就是对表的抽取<br>在真实开发项目中，我们会遇到很多基础表，这些基础表都有一个公共的特性：</p>
<pre><code>1. 字段非常少
2. 数据也非常少
</code></pre><p>使用数据字典的注意事项：</p>
<pre><code>1. 字段必须得少，最多三个字段
2. 如果该表存在，上下级关系也是不能用数据字典
3. 数据量不能过大，最多不超过20个以上
</code></pre><h1 id="图形化界面报表"><a href="#图形化界面报表" class="headerlink" title="图形化界面报表"></a>图形化界面报表</h1><ol>
<li>html5<ol>
<li>优点：占用带宽小，稳定</li>
<li>缺点：兼容性差(IE8以下是不能使用html5)</li>
</ol>
</li>
<li>flash<ol>
<li>优点：市面上基本上所有的浏览器都兼容</li>
<li>缺点：占用带宽大，不稳定<br>专门做图形化界面的插件：</li>
<li>ECharts</li>
<li>HightCharts<h1 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h1><h1 id="发送邮件"><a href="#发送邮件" class="headerlink" title="发送邮件"></a>发送邮件</h1></li>
</ol>
</li>
</ol>
<h1 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h1><h2 id="easyUi分页数据只展示第一页"><a href="#easyUi分页数据只展示第一页" class="headerlink" title="easyUi分页数据只展示第一页"></a>easyUi分页数据只展示第一页</h2><p>query里面加两个方法<br>    public void setPage(Integer page){<br>        this.currentPage=page;<br>    }<br>    public void  setRows(Integer rows){<br>        this.pageSize=rows;<br>    }</p>
<h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><h2 id="登录页面"><a href="#登录页面" class="headerlink" title="登录页面"></a>登录页面</h2><pre><code>1. 登录页面
2. 根据用户名动态显示头像 类似QQ登陆

//实时展示头像
$(function ($) {
    //1.校验用户输入的是正则表达式 先定义正则
    var emailFormat = /^[a-zA-Z0-9]/;
    // var flag = &apos;true&apos;;
    //2.当失去用户焦点的时候校验用户名
    var lastvalue = null;
    $(&apos;#user&apos;).on(&apos;blur&apos;, function () {
        //获取用户输入内容
        var value = $(this).val();
        if (!value || !emailFormat.test(value)) return;
        if (value !== lastvalue) {
            // 接下来需要通过用户名找到对应的头像地址，然后将头像地址改到img的src上
            $.get(&apos;/headImage&apos;, {name: value}, function (res) {
                if (!res) {
                    $(&apos;.avatar&apos;).fadeOut(function () {
                        $(this).on(&apos;load&apos;, function () {
                            $(this).fadeIn()
                        }).attr(&apos;src&apos;, &quot;&quot;);
                    })
                    $(&quot;#spanshow1&quot;).show()
                    $(&quot;#spanshow2&quot;).show()
                    return;
                }
hideSpan()
                $(&apos;.avatar&apos;).fadeOut(function () {
                    $(this).on(&apos;load&apos;, function () {
                        $(this).fadeIn()
                    }).attr(&apos;src&apos;, res);
                })

                // flag = false;
                // $(&apos;.avatar&apos;).fadeOut(function () {
                //   $(this).on(&apos;load&apos;,function () {
                //     $this.fadeIn();
                //   }).attr(&apos;src&apos;, res);
                // })
            })
        }
        lastvalue = value;
    })

})

3. 记住密码cookie

 saveCookie(){ //设置cookie
    var username = $(&quot;#user&quot;).val(); //获取用户名信息
    var password = $(&quot;#passwd&quot;).val(); //获取登陆密码信息
    var  img = $(&quot;#head&quot;).attr(&apos;src&apos;);
    console.debug(111)
    var checked = $(&apos;#brand1&apos;).val()//获取“是否记住密码”复选框
    if(checked==1){ //判断是否选中了“记住密码”复选框
        $.cookie(&quot;username&quot;,username);//调用jquery.cookie.js中的方法设置cookie中的用户名    
        $.cookie(&quot;password&quot;,$.base64.encode(password));//调用jquery.cookie.js中的方法设置cookie中的登陆密码，并使用base64（jquery.base64.js）进行加密    
        $.cookie(&quot;img&quot;,img);//调用jquery.cookie.js中的方法设置cookie中的登陆密码，并使用base64（jquery.base64.js）进行加密    
    }else{
        //$.cookie(&quot;password&quot;, null);
    }
}
function getCookie(){ //获取cookie    
    var username = $.cookie(&quot;username&quot;); //获取cookie中的用户名    
    var password =  $.cookie(&quot;password&quot;); //获取cookie中的登陆密码
    var  img = $.cookie(&quot;img&quot;);
    console.debug(img)
    if(password){//密码存在的话把“记住用户名和密码”复选框勾选住   
        $(&quot;#remberme&quot;).click();
    }
    if(username){//用户名存在的话把用户名填充到用户名文本框    
        $(&quot;#user&quot;).val(username);
    }
    if(password){//密码存在的话把密码填充到密码文本框    
        $(&quot;#passwd&quot;).val($.base64.decode(password));
    }
    if(img){//密码存在的话把密码填充到密码文本框    
        hideSpan()
        $(&quot;#head&quot;).attr(&quot;src&quot;,img)
    }
}
//清除cookie
function clearCookie(name) {
    $.cookie(name, &quot;&quot;, -1);
}
if ($.cookie(&quot;password&quot;)){
    getCookie()
}

4. 提示---display，opacity属性
</code></pre><h2 id="主页"><a href="#主页" class="headerlink" title="主页"></a>主页</h2><pre><code>1. 显示登录用户圆形头像
    .loginUser img{
        width: 50px;
        height: 50px;
        display: flex;
        border-radius: 50%;
        align-items: center;
        justify-content: center;
        overflow: hidden;
    }
2. 拖动标签页
3. 标签页右键菜单
</code></pre><h2 id="标签页面"><a href="#标签页面" class="headerlink" title="标签页面"></a>标签页面</h2><pre><code>1. 添加数据完成时跳到添加数据位置
2. 右键菜单
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/27/（Spring+SpringDataJPA+SpringMVC+EasyUI+Maven)-智能商贸/" data-id="cjy2n9fpm000ehwtda2r8fr1c" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-spring" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/24/spring/" class="article-date">
  <time datetime="2019-06-24T01:26:23.757Z" itemprop="datePublished">2019-06-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>title: spring<br>date: 2019-06-24 09:26:23</p>
<h2 id="tags"><a href="#tags" class="headerlink" title="tags:"></a>tags:</h2><h1 id="spring的核心"><a href="#spring的核心" class="headerlink" title="spring的核心"></a>spring的核心</h1><pre><code>1. IOC/DI：IOC指的是控制反转，所谓控制反转指的就是把所有的bean对象，交给spring容器进行管理，由spring统一来创建bean对象，这种创建对象的权利反转就叫做控制反转
2. AOP：面向切面编程，在你指定的service层，执行前或者执行后切一刀，然后织入自己的业务逻辑，能有效的进行解耦
3. AOP有什么作用：
    1. 抽取公共的业务逻辑代码
    2. 扩展功能
    3. 权限
    4. 日志

AOP底层是基于代理模式实现的：
    1. JDK动态代理：前提，你的目标类必须提供了一个接口，否则不能代理
    2. CGLIB动态代理：他可以代理的类，有实现接口，也可以没有实现接口
</code></pre><h1 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h1><h1 id="XML自动注入"><a href="#XML自动注入" class="headerlink" title="XML自动注入"></a>XML自动注入</h1><h1 id="全注解配置"><a href="#全注解配置" class="headerlink" title="全注解配置"></a>全注解配置</h1><p>@Autowired与@Resource的区别</p>
<pre><code>1. 都是注入bean对象
2. @Autowired是spring提供的注解，@Resource是sun公司提供的注解
3. @Autowired注入bean的时候，是先根据类型注入，再根据名字注入
4. 推荐使用@Autowired，@Autowired是spring公司的，与spring无缝衔接
</code></pre><h2 id="spring创建Bean的4中方式"><a href="#spring创建Bean的4中方式" class="headerlink" title="spring创建Bean的4中方式"></a>spring创建Bean的4中方式</h2><pre><code>1. &lt;bean class=&quot;类的全限定名&quot;/&gt;相当于java中的new 类名();
2. 使用FactoryBean来创建 FactoryBean专门创建复杂的对象
    1. 自定义类实现FactoryBean
    2. 复写3个抽象方法
        1. 是否单例
</code></pre><h3 id="BeanFactory和ApplicationContext的区别"><a href="#BeanFactory和ApplicationContext的区别" class="headerlink" title="BeanFactory和ApplicationContext的区别"></a>BeanFactory和ApplicationContext的区别</h3><pre><code>1. BeanFactory它是一个bean工厂，专门负责创建与管理所有的bean对象
2. BeanFactory它是要运行的时候才会去创建Bean对象，而ApplicationContext是BeanFactory的子接口
3. 而ApplicationContext是加载配置文件的时候，就会去创建对应的bean对象，所以以后我们都用ApplicationContext
</code></pre><h1 id="ssj的集成步骤"><a href="#ssj的集成步骤" class="headerlink" title="ssj的集成步骤"></a>ssj的集成步骤</h1><pre><code>1. 创建web项目
2. 导入相应的jar包
3. 配置ApplicationContext.xml文件
    1. 编写jdbc.properties
    2. DataSource
    3. EntityManagerFactory
        1. 依赖dataSource
        2. 扫描domain包
        3. 具体实现的框架
            方言
            是否显示sql
            建表策略
4. springMvc的核心配置
    1. 扫描controller包
    2. 开启springMvc注解支持
    3. 静态资源放行
    4. 视图解析器
5. web.xml
    1. 启动spring容器
    2. 启动springMvc容器
    3. 解决post提交乱码问题
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/24/spring/" data-id="cjy2n9fpa000ahwtd5y6xs7ve" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-phaser入门" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/21/phaser入门/" class="article-date">
  <time datetime="2019-06-21T11:46:02.000Z" itemprop="datePublished">2019-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/21/phaser入门/">phaser入门</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="phaser介绍"><a href="#phaser介绍" class="headerlink" title="phaser介绍"></a>phaser介绍</h1><p>phaser是一个</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/21/phaser入门/" data-id="cjy2n9fpc000bhwtdoabfm0ae" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JPA" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/17/JPA/" class="article-date">
  <time datetime="2019-06-17T01:40:25.000Z" itemprop="datePublished">2019-06-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/17/JPA/">JPA</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="JPA入门"><a href="#JPA入门" class="headerlink" title="JPA入门"></a>JPA入门</h1><p>ORM规范<br>    ORM：对象关系映射<br>作用:操作数据库<br>JPA是持久化规范，hibernate是其中一个实现</p>
<h2 id="JPA对比JDBC的优缺点"><a href="#JPA对比JDBC的优缺点" class="headerlink" title="JPA对比JDBC的优缺点"></a>JPA对比JDBC的优缺点</h2><p>JDBC:优点:</p>
<pre><code>   1. 操作数据库最底层，性能好控制
缺点:
   1. 使用复杂(重复代码太多)
   2. 移植数据库比较麻烦
   3. 如果要实现缓存，要自己手动去实现，性能上面没有相应的控制
   4. JDBC操作sql，jpa操作对象 
</code></pre><p>JPA:优点:</p>
<pre><code>    1. 操作简单
    2. 操作对象就相当于操作数据库
    3. 自带缓存提供
    4. 移植性比较好，只需要换一个方言
缺点:
    1. 不能干预sql语句的生成，性能不好控制 
    2. 如果一个项目对sql比较高，不适合用jpa
    3. 如果一个表中有上亿级别的数据量，不适合用jpa，也不适合用jdbc(架构使用数据库读写分离，分库分表方案解决)
</code></pre><h2 id="连接数据库的配置"><a href="#连接数据库的配置" class="headerlink" title="连接数据库的配置"></a>连接数据库的配置</h2><pre><code>1. 四个基本配置
2. 配置方言
3. shou_sql
    是否显示sql语句
4. 让jpa自动创建相应的表
    hbm2ddl.auto
</code></pre><h2 id="自动建表"><a href="#自动建表" class="headerlink" title="自动建表"></a>自动建表</h2><pre><code>添加注解
    类上
        @Entity
            JPA就知道这里有个对象
        @Table(name=&quot;表名&quot;)
            代表对象与那张表建立关系
            可以不写，表名就是类名
    属性上
        @Id
            主键
            JPA中必须有主键
            JPA要求主键必须是serializable类型
            @GeneratedValue
                主键生成策略
                    主键
                        确定一条数据的唯一性
                            非空且唯一
                    自然主键
                        主键是有意义的
                    用代理主键
                        主键是没有意义的
                            没有意义的数据我们不需要自动填写，自动生成就行了
                                保持唯一性
                IDENTITY
                    自增策略
                        要求
                            主键必需是数字
                            数据库必需支持这个策略
                        性能高
                SEQUENCE
                    序列
                        序列对象
                        看起来还是自增
                        要求
                            主键必需是数字
                            数据库必需支持这个策略
                        性能更高
                AUTO
                    自动区分用的数据库，自动选择使用IDENTITY还是SEQUENCE
                    默认策略
                TABLE
                    表策略
                        兼容所有数据库
                        模拟序列
                        性能稍差
        @ManyToOne
            外键
                告诉JPA这里是个多对一
            fetch：抓取策略
                FetchType.EAGER
                    及时加载
                        默认
                FetchType.LAZY
                    懒(延时)加载，要用时才进行数据加载
            @JoinColum(name=&quot;外键名称&quot;)
                设置外键的名称
                子主题 2
        @Colimn（属性名=别名，length=20，unique=true，nullable=false）
            改别名
            长度改为20
            唯一
            不能为空
        @Transient
            临时属性
                数据库中不要加上
        @Lob
            longtext
        @Temporary
建表策略
    create-drop    
        删除-创建
    create
        删除-创建
    update
        没有表就创建，有表就修改
    validate
        验证你的domin和表是否对应上
</code></pre><h2 id="核心API"><a href="#核心API" class="headerlink" title="核心API"></a>核心API</h2><pre><code>1. Persistence
    持久化对象
    创建EntityManagerFactory对象
2. EntityManagerFactory
    EntityManager工厂对象
    创建EntityManager对象
    特点
        重量级对象
            重
                数据源【连接池】
                二级缓存
                    导jar包
                    配置信息Second-level Cache
                    添加persistence.xml配置信息
                    二级缓存命中
                        同一个EntityManagerFactory，不同EntityManager同一个OID
                    使用场景
                        读取大于配置
                        独享控制权
                        允许出现无效数据
                        数据量不能过大
                所有jpa的配置
                预编译的SQL/JPQL
        这个对象不能随意销毁
            1:1:1--&gt;一个项目：1个EntityManagerFacttory：一个数据库
        这个对象线程安全
            线程安全影响性能
3. EntityManager
    操作数据库（CRUD）
        增删改必须提交事务
    方法
        merge
            添加或者修改
    特点
        轻
            连接对象
            一级缓存
                提高了查询速度
                默认提供
                一级缓存命中
                    同一个EntityManagerFactory，同一个EntityManager同一个OID
        一般来说，一个线程/一次请求 用一次EntityManager
        线程不安全
EntityTransaction
    事务对象（一组操作，要不都成功，要不都失败）
    JPA 增删改一定要有事务
    多个数据库：JTA
</code></pre><h2 id="对象的状态"><a href="#对象的状态" class="headerlink" title="对象的状态"></a>对象的状态</h2><pre><code>1. 四个状态
    1. 临时状态（瞬时状态）
        对象刚刚创建出来还没有与entityManager发生关系
    2. 持久化状态（托管状态）
        对象与entityManager发生关系了
            对象就存在一级缓存中，在一级缓存中的对象也就是持久化对象
        持久化的对象会不会被修改和merge方法没有关系
        只能删除持久化状态的对象
        不能修改OID
    3. 游离状态（脱管状态）
        对象与entityManager解除了关系
            从一级缓存中移除了
    4. 删除状态
        hibernate中没有删除状态
        只要调用了remove方法，这个对象就变成删除状态，JPA就要计划把他删除了
        删除状态是一种特殊的持久化状态
            还在一级缓存中
2. 脏数据更新
    提交数据的时候进行脏数据更新
3. 报错
    n-to-n:持久化对象的OID不能修改
    no session:会话关闭后去拿取数据（懒加载）
</code></pre><h2 id="域对象-domain对象-的关系"><a href="#域对象-domain对象-的关系" class="headerlink" title="域对象(domain对象)的关系"></a>域对象(domain对象)的关系</h2><pre><code>1. 依赖关系
    javabean之间的依赖关系
    分层:表现层,业务层,持久层(依赖关系)
    Controller表现层依赖于Service业务层，Service依赖于Dao持久层
2. 关联关系
    类之间的引用关系，以属性定义的关系表现
    多重性
        一对一
            共享主键
            唯一外键（建议）
            默认迫切加载
        多对一
            有外键关系，外键在哪边，哪边就是多方
            先保存一方在保存多方
                性能高
            默认迫切加载
                改为懒加载
        一对多
            默认懒加载
                集合默认懒加载
        多对多
            中间表
                JoinTable
                    name
                        自定义中间表名字
                    JoinColumns
                        当前类对应的列名
                    inverseJoinColumns
                        对应关系表列名
            集合
                默认懒加载
            双向的多对多
                必须保存表名和列名都是一致的
            子主题 4
    导航性
3. 聚合关系
    双向的多对一，一对多
        让一方放弃关系维护
            两边都在维护
            mappedBy=&quot;多方维护的字段名&quot;
        级联
            cascade=
                CascadeType.PERSIST
                    级联添加
                CascadeType.REMOVE
                    级联删除
                CascadeType.MERGE
                    级联修改
                CascadeType.ALL
                    包含级联增删改
            非常危险的操作，请慎用
                特别是级联删除
            orpherRemove
                孤儿删除
            组合关系一定要用级联
                用最强级联
            凡是单据都是组合关系
4. 组合关系
    强聚合(整体和部分不可分割)
</code></pre><h2 id="hibernate"><a href="#hibernate" class="headerlink" title="hibernate"></a>hibernate</h2><pre><code>操作数据库的框架
    ORM框架
数据库
    关系型数据库
java语言
    面向对象的语言
是jpa的完美实现
</code></pre><h2 id="JPQL"><a href="#JPQL" class="headerlink" title="JPQL"></a>JPQL</h2><pre><code>JPA的查询语言
    面向对象
兼容各种数据库
底层是SQL
使用
    查询结果过滤
        select o from 表名 o where 
    查询排序
        子主题 1
    使用关联对象属性排序
    去重
        distinct
    size
    连接
    jpql关联    黄金法则
            不需要消灭笛卡尔积
            关联的是前面的对象的别名，属性
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/17/JPA/" data-id="cjy2n9fp50005hwtd319z51o7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-maven-idea-uml" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/16/maven-idea-uml/" class="article-date">
  <time datetime="2019-06-16T01:15:41.000Z" itemprop="datePublished">2019-06-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/16/maven-idea-uml/">maven&amp;idea&amp;uml</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Maven——一个优秀的项目构建工具"><a href="#Maven——一个优秀的项目构建工具" class="headerlink" title="Maven——一个优秀的项目构建工具"></a>Maven——一个优秀的项目构建工具</h1><p>Maven项目对象模型(pom)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><pre><code>1. 自动构建(mvn jetty:run 清理,编译,测试,部署)
2. 自动导包 pom.xml中配置，先找本地仓库，如果没有，找中央仓库
3. 契约编程(代码更加规范)
</code></pre><h2 id="Maven安装"><a href="#Maven安装" class="headerlink" title="Maven安装"></a>Maven安装</h2><pre><code>1. 在需要安装的路径下解压maven
2. 配置MAVEN_HOME环境
3. 执行mvn命令 生成一个
</code></pre><h2 id="修改默认本地仓库"><a href="#修改默认本地仓库" class="headerlink" title="修改默认本地仓库"></a>修改默认本地仓库</h2><h2 id="maven命令"><a href="#maven命令" class="headerlink" title="maven命令"></a>maven命令</h2><p>mvn compile：编译(有点像javac)<br>mvn clean:清理<br>mvn clean compile:先清理，后编译<br>mvn test:测试(运行几个，失败几个，错误几个)<br>mvn package:打包<br>mvc source:jar:打源码包<br>mvn site：生成一个网站(文档)<br>mvn install:把jar包打好放到本地仓库<br>mvn eclipse:eclipse -&gt; 变成eclipse的结构<br>mvn package -Dmaven.test.skip=true -&gt; 打包的时候跳过测试</p>
<h1 id="IDEA——最好的java开发环境之一"><a href="#IDEA——最好的java开发环境之一" class="headerlink" title="IDEA——最好的java开发环境之一"></a>IDEA——最好的java开发环境之一</h1><h1 id="UML-统一建模语言"><a href="#UML-统一建模语言" class="headerlink" title="UML :统一建模语言"></a>UML :统一建模语言</h1><p>用例图:看权限的图<br>类图:类的关系(继承,多对一，一对多等，组合与聚合关系)<br>流程图:请假流程，开会流程</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/16/maven-idea-uml/" data-id="cjy2n9fp90009hwtdf017q2mj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-EasyUI" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/13/EasyUI/" class="article-date">
  <time datetime="2019-06-13T01:17:12.000Z" itemprop="datePublished">2019-06-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/13/EasyUI/">EasyUI</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="EasyUI的认识"><a href="#EasyUI的认识" class="headerlink" title="EasyUI的认识"></a>EasyUI的认识</h2><ol>
<li>是基于JQuery的ui(界面)插件集合</li>
<li>不需要编写复杂的JavaScript，也不需要对css样式有深入了解，开发者只需要了解一些简单的html标签</li>
<li>学习方式copy+edit<h2 id="EasyUI使用"><a href="#EasyUI使用" class="headerlink" title="EasyUI使用"></a>EasyUI使用</h2></li>
</ol>
<ol>
<li>下载导入easyui文件</li>
<li><p>在对应页面引入easyui的js文件和css文件</p>
<p> &lt;%–引入easyui的样式–%&gt;<br> <link rel="stylesheet" type="text/css" href="js/easyui/themes/default/easyui.css"><br> &lt;%–引入easyui的图标–%&gt;<br> <link rel="stylesheet" type="text/css" href="js/easyui/themes/icon.css"><br> &lt;%–引入jquery的js文件–%&gt;</p>
 <script type="text/javascript" src="js/easyui/jquery.min.js"></script>
 <%--引入easyui的js文件--%>
 <script type="text/javascript" src="js/easyui/jquery.easyui.min.js"></script>
 <%--国际化--%>
 <script type="text/javascript" src="js/easyui/locale/easyui-lang-zh_CN.js"></script>
</%--国际化--%></%--引入easyui的js文件--%></li>
<li><p>使用easyui里面的组件</p>
<ol>
<li><p>直接通过标签来使用<br> 核心添加class=“easyui-组件名”</p>
<p> `&lt;div id=”p” class=”easyui-panel” title=”My Panel”</p>
<pre><code>style=&quot;width:500px;height:150px;padding:10px;background:#fafafa;&quot;
data-options=&quot;iconCls:&apos;icon-save&apos;,closable:true,
collapsible:true,minimizable:true,maximizable:true&quot;&gt;
&lt;p&gt;panel content.&lt;/p&gt;
&lt;p&gt;panel content.&lt;/p&gt;
</code></pre><p> `</p>
</li>
<li><p>通过js创建组件<br><code>&lt;div id=&quot;p&quot; style=&quot;padding:10px;&quot;&gt;
 &lt;p&gt;panel content.&lt;/p&gt;
 &lt;p&gt;panel content.&lt;/p&gt;
&lt;/div&gt;
$(&#39;#p&#39;).panel({
 width:500,
 height:150,
 title:&#39;My Panel&#39;,
 tools:[{
 iconCls:&#39;icon-add&#39;,
 handler:function(){alert(&#39;new&#39;)}
 },{
 iconCls:&#39;icon-save&#39;,
 handler:function(){alert(&#39;save&#39;)}
 }]
});</code></p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2></li>
<li>一般在创建组件的时候，就应该指定好对应属性，不然，如果创建完之后，在修改对应属性，就没有效果</li>
<li>指定属性 在 标签里面指定 ，在js代码在创建的时候，也可以指定；<h2 id="组件三要素"><a href="#组件三要素" class="headerlink" title="组件三要素"></a>组件三要素</h2></li>
</ol>
</li>
</ol>
<ol>
<li>属性:通过标签里面属性，可以让组件展示不同的效果，完成不同的功能<ol>
<li>在组建创建时都有默认属性</li>
<li>属性只能在创建(初始化)组件有效，组件创建完毕后，对某个属性修改无效</li>
<li>属性定义方式<ol>
<li>方式一:直接在标签里面写 属性=属性值</li>
<li>方式二:data-options<br> 注意一:如果在标签里面定义一个属性和在data-options里面定义同一属性，标签里面有效果<br> 注意二:有些属性只能写到data-options里面 想tools这种属性，有多个值，不能放到外面</li>
<li>方式三:直接在js中写</li>
</ol>
</li>
</ol>
</li>
<li>方法:<ol>
<li>调用方法：<br> $(“selector”).组件名(methodName,[params])</li>
<li>创建组件<br> $(“selector”).组件名（{属性键值对}）</li>
</ol>
</li>
<li><p>事件</p>
<p> //点击事件<br> onClick: function(node){</p>
<pre><code>alert(node.text);  // 在用户点击的时候提示
</code></pre><p> },</p>
</li>
</ol>
<h2 id="常用组件"><a href="#常用组件" class="headerlink" title="常用组件"></a>常用组件</h2><ol>
<li>Tabs选项卡</li>
<li>message消息提示框</li>
<li>Form表单</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/13/EasyUI/" data-id="cjy2n9fp10002hwtdib1mcefw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-js高级" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/11/js高级/" class="article-date">
  <time datetime="2019-06-11T01:15:53.000Z" itemprop="datePublished">2019-06-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/11/js高级/">js高级</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="js对象"><a href="#js对象" class="headerlink" title="js对象"></a>js对象</h2><pre><code>&lt;script&gt;
    //js是一个基于对象和事件驱动编程语言
    //1.js一切皆是对象，你可以把基本类型，引用类型，函数都可以看做对象
    var num = 2.134141;
    console.debug(num.toFixed(2));//保留两位小数

    //2.js中的true和false
    var boo = false;
     if (boo){
        console.debug(&quot;不能进入&quot;)
    }
    var boo2 = new Boolean(false);
     if (boo2){
         console.debug(&quot;可以进入&quot;)
     }
     if(NaN){
         console.debug(&quot;不能进入&quot;)
     }

    //3.对象的操作
    //创建对象的方式
    var obj1 = new Object();
    var obj2 = {};
    var obj3 = new user();
    function user() {

    }
    console.debug(obj1)
    console.debug(obj2)
    console.debug(obj3)
    //给对象添加属性和方法
    obj3.name=&quot;小c&quot;;
    obj3[&quot;age&quot;]=&quot;22&quot;;
    obj3.play=function (game) {
        console.debug(this.name+&quot;玩&quot;+game)
    }
    //调用方法
    obj3.play(&quot;lol&quot;)

    //遍历对象
    for (var key in obj3){
        console.debug(key)

        //如果是方法就调用方法
        if (typeof obj3[key] == &quot;function&quot;){
            obj3[key](&quot;lol&quot;);
        }else {//是属性直接取值
            console.debug(obj3[key])
        }
    }
&lt;/script&gt;
</code></pre><h2 id="json对象和json字符串"><a href="#json对象和json字符串" class="headerlink" title="json对象和json字符串"></a>json对象和json字符串</h2><pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;../../js/jquery.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    //json字符串
    var jsonStr = &quot;{&apos;id&apos;:1,&apos;name&apos;:&apos;霸哥&apos;}&quot;;
    //json对象转换
    var jsonObj = eval(&quot;(&quot;+jsonStr+&quot;)&quot;);
    console.debug(jsonObj)

    //Json.parse()--必须是json标准格式
    //var obj=$.parseJSON(jsonStr)
    var jsonStr2 = &apos;{&quot;id&quot;:1,&quot;name&quot;:&quot;霸哥&quot;}&apos;;
    var obj=$.parseJSON(jsonStr2)
    console.debug(obj)
&lt;/script&gt;
</code></pre><h2 id="js类"><a href="#js类" class="headerlink" title="js类"></a>js类</h2><pre><code>&lt;script&gt;
    //类构造方法在写的时候，如果方法首字母是大写，一般认为是构造方法
    function Person(name,age) {
        this.name=name;
        this.age=age;
    }

    //属性拷贝
    //方式2 一个一个拷贝
    var obj1 = {
        name:&quot;gg&quot;,
        age:&quot;18&quot;
    }
    var obj2 = {
    }
    obj2.name=obj1.name;
    obj2.age=obj1.age;
    console.debug(obj2)
    //方式3 循环对象
    for (var key in obj1){
        if (!obj2.hasOwnProperty(key)){//判断里面是否有属性
            obj2[key]=obj1[key];
        }
    }
    console.debug(obj2)
&lt;/script&gt;
</code></pre><h2 id="js的prototype"><a href="#js的prototype" class="headerlink" title="js的prototype"></a>js的prototype</h2><pre><code>&lt;script&gt;
    //prototype:原型的意思--js对象都有prototype属性，使你可以向对象添加属性和方法
    //使用
    /**
     * 对象组成 ：自定义属性
     *             原型属性
     *      先从自定义属性对象中找，找不到到原型里面找
     */
    function User(name,age) {
        this.name=name;
        this.age=age;
    }
    var user1=new User(&quot;彩旗&quot;,23)
    var user2=new User(&quot;天霸&quot;,23)
    //展示目录结构
    console.dir(user1)
    console.dir(user2)
    //对象里面的原型属性__proto__ ，对象里面原型属性是相同或者共享
    console.debug(user1.__proto__ === user2.__proto__)
    //原型上面定义方法
    User.prototype.eat=function (food) {
        console.debug(this.name+&quot;吃&quot;+food)
    }
&lt;/script&gt;
</code></pre><h2 id="js中的回调函数"><a href="#js中的回调函数" class="headerlink" title="js中的回调函数"></a>js中的回调函数</h2><pre><code>&lt;script&gt;
    //函数：方法 实现一块逻辑，一堆代码打包成一个方法
    //普通函数:function user(){}
    //构造函数:function User(){}
    //回调函数:函数作为一个参数，传递给另一个函数，重新回调这个函数
    setTimeout(test,3000);//异步
    function test() {
        console.debug(111)
    }
    console.debug(222)
    //匿名函数:没有名字的函数
    // 作用：1,如果变量只用一次的时候 可以放到匿名函数中  解决作用域污染问题
    //       2，作为参数传递
    (function (a,b) {
        var result=a+b;
        //window.result=result;暴露到window中
    })(7,7);
&lt;/script&gt;
</code></pre><h2 id="jquery事件委托"><a href="#jquery事件委托" class="headerlink" title="jquery事件委托"></a>jquery事件委托</h2><pre><code>&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
&lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;title&gt;Title&lt;/title&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;../../js/jquery.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
    //事件委托:给动态元素添加事件

    //绑定事件
    $(function () {
        $(&quot;#add&quot;).click(function () {
            var content = &quot;&lt;div&gt;\n&quot; +
                &quot;        附件:&lt;input type=\&quot;file\&quot; name=\&quot;file\&quot;&gt;\n&quot; +
                &quot;        &lt;a class=\&quot;delete\&quot; href=\&quot;javascript:;\&quot;&gt;删除&lt;/a&gt;\n&quot; +
                &quot;        &lt;a class=\&quot;examine\&quot; href=\&quot;javascript:;\&quot;&gt;查看&lt;/a&gt;\n&quot; +
                &quot;    &lt;/div&gt;&quot;;
            $(&quot;#userForm&quot;).append(content);
        })
        //事件委托
        $(&quot;#userForm&quot;).on(&apos;click&apos;,&apos;.delete&apos;,function () {
            console.debug(&quot;删除&quot;)
        })
    })

&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;a id=&quot;add&quot; href=&quot;javascript:;&quot;&gt;添加&lt;/a&gt;
&lt;form id=&quot;userForm&quot;&gt;
&lt;div&gt;
    附件:&lt;input type=&quot;file&quot; name=&quot;file&quot;&gt;
&lt;/div&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h2 id="js的闭包"><a href="#js的闭包" class="headerlink" title="js的闭包"></a>js的闭包</h2><pre><code>&lt;script&gt;
    //闭包：函数内使用函数外的变量
    var a=10;
    function b() {
        alert(a)
    }
    //闭包案例--计数案例
    var  result=0;
    function getSum() {
        return result++;
    }
    console.debug(getSum());
    console.debug(getSum());
    result=0;
    console.debug(getSum())

    //使用闭包和匿名函数结合起来使用
    (function () {
        var result1=0;
        window.getSum1=function () {
            result1++;
            return result1;
        }
    })();
    console.debug(getSum1());
    console.debug(getSum1());
    //result1=10;
    console.debug(getSum1());
&lt;/script&gt;
</code></pre><h2 id="js里面的this用法"><a href="#js里面的this用法" class="headerlink" title="js里面的this用法"></a>js里面的this用法</h2><p>this的指向的改变</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/11/js高级/" data-id="cjy2n9fp60006hwtdsbjghyo5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-jQuery" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/10/jQuery/" class="article-date">
  <time datetime="2019-06-10T01:14:35.000Z" itemprop="datePublished">2019-06-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/10/jQuery/">jQuery</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="jQuery——write-less-do-more"><a href="#jQuery——write-less-do-more" class="headerlink" title="jQuery——write less do more"></a>jQuery——write less do more</h1><p>jQuery:优秀的js框架</p>
<h2 id="jQuery的使用"><a href="#jQuery的使用" class="headerlink" title="jQuery的使用"></a>jQuery的使用</h2><ol>
<li>引入jquery文件<br> <code>&lt;script type=&quot;text/javascript&quot; src=&quot;/js/jquery.min.js&quot;&gt;&lt;/script&gt;</code></li>
<li><p>页面加载事件</p>
<pre><code>//页面加载完之后再执行代码，先于window.onload执行
$(function(){

})
</code></pre></li>
<li>jquery中$和jQuery<br> $ === jQuery<br> 如果其他框架里面也使用了$符号，就使用jQuery的写法</li>
<li><p>DOM对象和jquery对象的转换</p>
<pre><code>$(function(){
    //dom对象
    var domObj = document.getElementById(&quot;mySpan&quot;);

    //jquery对象
    var jqueryObj = $(&quot;#mySpan&quot;);

    //有时候需要把dom对象转成jquery对象--可以调用jquery里面的方法
    var domToJquery = $(domObj);

    //有时候需要把jquery对象转成dom对象--可以使用dom原生的属性和方法
    var jqueryToDom = jqueryObj[0];
})
</code></pre></li>
<li><p>选择器</p>
<pre><code>//id选择器 id一般不重复
$(&quot;#id&quot;);

//class选择器
$(&quot;.class&quot;);

//标签选择器 页面上的所有标签都有效果
$(&quot;div&quot;);

//获取所有元素--没什么用
$(&quot;*&quot;);

//多元素选择器
$(&quot;div,span&quot;)

//层次选择器
//祖先后代
$(&quot;div span&quot;)
//父亲儿子
$(&quot;div &gt; span&quot;)
//相邻选择器
$(&quot;input + input&quot;)
//同级选择器
$(&quot;form ~ input&quot;)

//属性选择器
</code></pre></li>
<li><p>jquery注册事件方式<br> //方式一注册事件<br> $(“#id”).click(function(){<br> })</p>
<p> //方式二注册事件<br> $(“#id”).on(‘click’,function(){<br> })<br> //取消事件<br> $(“#id”).off(‘click’)</p>
<p> //方式三注册事件<br> $(“#id”).bind(‘click’,function(){<br> })<br> //取消事件<br> $(“#id”).unbind(‘click’);</p>
</li>
<li>jquery常用方法</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/10/jQuery/" data-id="cjy2n9fp70007hwtdc8c2hec0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-AJAX" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/09/AJAX/" class="article-date">
  <time datetime="2019-06-09T01:12:45.000Z" itemprop="datePublished">2019-06-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/09/AJAX/">AJAX</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="js"><a href="#js" class="headerlink" title="js"></a>js</h2><h3 id="js的引入方式"><a href="#js的引入方式" class="headerlink" title="js的引入方式"></a>js的引入方式</h3><ol>
<li>直接在行内标签内使用</li>
<li>在<script>标签内使用</li>
<li>外部js引入<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3></li>
<li>如果引入外部js文件，就不要再这个标签内写内容</li>
<li><script>标签引入文件不能使用单标签</li>
<li>js加载顺序是从上往下</li>
<li><p><a herf="#">点击</a>存在锚点效果</p>
<h3 id="js里面的函数"><a href="#js里面的函数" class="headerlink" title="js里面的函数"></a>js里面的函数</h3><p>什么是函数：函数就是方法，function<br>函数的定义<br> function say(name,food){</p>
<p> }<br>函数调用<br> 调用方法，参数可以多，如果参数传少了，默认值是undefined666<br> say();<br> window.say();<br>动态调用<br> window<a href="">“say”</a>;<br>js中一切皆对象，函数也是对象</p>
</li>
</ol>
<p>函数返回值<br>    如果方法没有返回值，返回undefined</p>
<p>java 方法重载：方法名相同，参数列表不同，和返回值无关<br>js没有重载一说，方法名相同，后面的方法会覆盖前面的方法</p>
<h3 id="js引擎执行过程"><a href="#js引擎执行过程" class="headerlink" title="js引擎执行过程"></a>js引擎执行过程</h3><p>js变量提升</p>
<h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><p>ajax即Asynchronous JavaScript And XML<br>异步JavaScript和XML，是指一种创建交互式网页应用的网页开发技术<br>异步JavaScript：浏览器处理事情，如果没有处理完，可以做其他事情<br>XML：可拓展性标记语言<br>局部刷新技术，是前端技术，属于js里面的内容</p>
<h3 id="获取服务器时间"><a href="#获取服务器时间" class="headerlink" title="获取服务器时间"></a>获取服务器时间</h3><h2 id="json"><a href="#json" class="headerlink" title="json"></a>json</h2><p>json:JavaScript Object Notation<br>一种轻量级的数据交换格式</p>
</script></li></ol>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/09/AJAX/" data-id="cjy2n9fou0000hwtdp6gx0m3w" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/07/14/面试题/">面试题</a>
          </li>
        
          <li>
            <a href="/2019/06/27/（Spring+SpringDataJPA+SpringMVC+EasyUI+Maven)-智能商贸/">(Spring+SpringDataJPA+SpringMVC+EasyUI+Maven)-智能商贸</a>
          </li>
        
          <li>
            <a href="/2019/06/24/spring/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/06/21/phaser入门/">phaser入门</a>
          </li>
        
          <li>
            <a href="/2019/06/17/JPA/">JPA</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 sunlei<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>