<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>java学习笔记</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="java学习笔记">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="java学习笔记">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java学习笔记">
  
    <link rel="alternate" href="/atom.xml" title="java学习笔记" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">java学习笔记</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-springboot" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/13/springboot/" class="article-date">
  <time datetime="2019-08-13T00:58:26.000Z" itemprop="datePublished">2019-08-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/13/springboot/">springboot</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>HelloWorld</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/08/13/springboot/" data-id="cjz96v1vy000fhktd8cc3t3b5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Elasticsearch" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/11/Elasticsearch/" class="article-date">
  <time datetime="2019-08-11T01:11:00.000Z" itemprop="datePublished">2019-08-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/11/Elasticsearch/">ElasticSearch</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1-ElasticSearch的基本概念"><a href="#1-ElasticSearch的基本概念" class="headerlink" title="1. ElasticSearch的基本概念"></a>1. ElasticSearch的基本概念</h3><p>ElasticSearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java语言开发的，并作为Apache许可条款下的开放源码发布，是一种流行的企业级搜索引擎。ElasticSearch用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。官方客户端在Java、.NET（C#）、PHP、Python、Apache Groovy、Ruby和许多其他语言中都是可用的。</p>
<h3 id="2-ES的特点"><a href="#2-ES的特点" class="headerlink" title="2. ES的特点"></a>2. ES的特点</h3><ul>
<li>Es 全文检索框架 使用比lucene更简单</li>
<li>ES支持集群 支持分布式</li>
<li>支持json操作</li>
<li>一般大型全文检索都用ES</li>
<li><p>通过Restfull风格操作ES</p>
<h3 id="3-Es和Lucene的区别"><a href="#3-Es和Lucene的区别" class="headerlink" title="3. Es和Lucene的区别"></a>3. Es和Lucene的区别</h3><p>Lucene：</p>
</li>
<li><p>使用起来很复杂</p>
</li>
<li>Lucene不支持集群</li>
<li>扩展麻烦</li>
<li>必须使用Java<h3 id="4-安装ES"><a href="#4-安装ES" class="headerlink" title="4. 安装ES"></a>4. 安装ES</h3></li>
</ul>
<ol>
<li>解压ES文件</li>
<li><p>安装Kinaba</p>
<h3 id="5-ES的crud"><a href="#5-ES的crud" class="headerlink" title="5. ES的crud"></a>5. ES的crud</h3><h3 id="java操作es"><a href="#java操作es" class="headerlink" title="java操作es"></a>java操作es</h3><p> //获取客户端<br> public static TransportClient getClient() throws Exception {</p>
<pre><code>TransportClient client = new PreBuiltTransportClient(Settings.EMPTY).
        addTransportAddress(new InetSocketTransportAddress(InetAddress.getByName(&quot;localhost&quot;),
                9300));
return client;
</code></pre><p> }</p>
<p> //保存一条记录<br> @Test<br> public void createEsIndex() throws Exception {</p>
<pre><code>TransportClient client = getClient();
//创建索引库
IndexRequestBuilder indexRequestBuilder = client.prepareIndex(&quot;crm&quot;, &quot;user&quot;, &quot;1&quot;);
Map map = new HashMap();
map.put(&quot;id&quot;, 1);
map.put(&quot;name&quot;, &quot;huahua&quot;);
map.put(&quot;age&quot;, 18);
IndexResponse indexResponse = indexRequestBuilder.setSource(map).get();
System.out.println(indexResponse);
</code></pre><p> }</p>
<p> //获取数据<br> @Test<br> public void testGet() throws Exception {</p>
<pre><code>//获取client对象
TransportClient client = getClient();
//取到值
GetResponse response = client.prepareGet(&quot;crm&quot;, &quot;user&quot;, &quot;1&quot;).get();
//获取source部分数据
System.out.println(response.getSource());
</code></pre><p> }</p>
<p> @Test<br> public void testUpdate() throws Exception {</p>
<pre><code>//获取client对象
TransportClient client = getClient();
Map mp = new HashMap();
mp.put(&quot;id&quot;, 1);
mp.put(&quot;name&quot;, &quot;jojo&quot;);
mp.put(&quot;age&quot;, 22);
//取到值
UpdateResponse updateResponse = client.prepareUpdate(&quot;crm&quot;, &quot;user&quot;, &quot;1&quot;).setDoc(mp).get();
GetResponse response = client.prepareGet(&quot;crm&quot;, &quot;user&quot;, &quot;1&quot;).get();
//获取source部分数据
System.out.println(response.getSource());
</code></pre><p> }</p>
<p> @Test<br> public void testDelete() throws Exception {</p>
<pre><code>//获取client对象
TransportClient client = getClient();

//取到值
DeleteResponse deleteResponse = client.prepareDelete(&quot;crm&quot;, &quot;user&quot;, &quot;1&quot;).get();

//获取source部分数据
System.out.println(deleteResponse);
</code></pre><p> }<br> //批量操作<br> @Test<br> public  void testGetBulk()throws Exception{<br> //获取客户端</p>
<pre><code>TransportClient client = getClient();
//获取批量请求对象
BulkRequestBuilder bulk = client.prepareBulk();
for (int i = 0; i &lt; 10; i++) {
    Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();
    map.put(&quot;id&quot;, i);
    map.put(&quot;name&quot;, &quot;sl&quot; + i);
    map.put(&quot;age&quot;, 18 + i);
    map.put(&quot;class&quot;,1);
    BulkRequestBuilder builder = bulk.add(client.prepareIndex(&quot;crm&quot;, &quot;user&quot;, i + &quot;&quot;).setSource(map));
}
//提交请求
BulkResponse bulkResponse = bulk.get();
if (bulkResponse.hasFailures()) {
    System.out.println(&quot;error!!!!&quot;);
}
//关闭资源
client.close();
</code></pre><p> }<br> //搜索<br> @Test<br> public  void test()throws Exception{</p>
<pre><code>//获取客户端
TransportClient client = getClient();
//创建boolQuery对象
BoolQueryBuilder boolQuery = QueryBuilders.boolQuery();
// 匹配 class =1
List&lt;QueryBuilder&gt; must = boolQuery.must();
must.add(QueryBuilders.termQuery(&quot;class&quot;,&quot;1&quot;));
//搜索年龄范围在18-23的班级在1班的，并且按照id降序，展示第一页，三条数据
List&lt;QueryBuilder&gt; filter = boolQuery.filter();
filter.add(QueryBuilders.rangeQuery(&quot;age&quot;).gte(18).lte(23));
SearchResponse searchResponse = client.prepareSearch(&quot;crm&quot;)
        .setFrom(0).setSize(3)
        .setQuery(boolQuery)
        .addSort(&quot;id&quot;, SortOrder.DESC).get();

System.out.println(&quot;总条数:&quot;+searchResponse.getHits().getTotalHits());
SearchHit[] hits = searchResponse.getHits().getHits();
// 循环数据结构
for (SearchHit hit : hits) {
    System.out.println(hit.getSource());
}
// 关闭资源
client.close();
</code></pre><p> }</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/08/11/Elasticsearch/" data-id="cjz96v1uy0000hktd96w4p5mz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Redis" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/10/Redis/" class="article-date">
  <time datetime="2019-08-10T01:18:25.000Z" itemprop="datePublished">2019-08-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/10/Redis/">Redis</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Nosql"><a href="#Nosql" class="headerlink" title="Nosql"></a>Nosql</h2><h3 id="1-Nosql的概念"><a href="#1-Nosql的概念" class="headerlink" title="1. Nosql的概念"></a>1. Nosql的概念</h3><p>NoSql指非关系型数据库，性能高，解决高并发问题</p>
<h3 id="2-Nosql的分类"><a href="#2-Nosql的分类" class="headerlink" title="2. Nosql的分类"></a>2. Nosql的分类</h3><ul>
<li>key-value键值对数据库</li>
<li>列式存储数据库</li>
<li>文档型结构数据库</li>
<li>图形结构数据库<h2 id="Redis介绍"><a href="#Redis介绍" class="headerlink" title="Redis介绍"></a>Redis介绍</h2><h3 id="1-Redis的概念"><a href="#1-Redis的概念" class="headerlink" title="1. Redis的概念"></a>1. Redis的概念</h3>Redis是属于Key-Value键值对数据库，是Nosql的一种<h3 id="2-Redis的特点"><a href="#2-Redis的特点" class="headerlink" title="2. Redis的特点"></a>2. Redis的特点</h3></li>
<li>数据存储到内存</li>
<li>支持数据持久</li>
<li>支持Redis集群</li>
<li>支持事务</li>
<li>支持订阅发布<h3 id="3-Redis的使用场景"><a href="#3-Redis的使用场景" class="headerlink" title="3. Redis的使用场景"></a>3. Redis的使用场景</h3></li>
<li>中央缓存</li>
<li>计数器</li>
<li>实时防攻防系统</li>
<li>排行榜</li>
<li>有效时间</li>
<li>去重</li>
<li>队列</li>
<li>发布订阅<h2 id="Redis的安装"><a href="#Redis的安装" class="headerlink" title="Redis的安装"></a>Redis的安装</h2><h2 id="Redis的常用命令"><a href="#Redis的常用命令" class="headerlink" title="Redis的常用命令"></a>Redis的常用命令</h2><h3 id="1-String的基本操作"><a href="#1-String的基本操作" class="headerlink" title="1. String的基本操作"></a>1. String的基本操作</h3>设置值：set key value<br>取值：get key<br>同时设置一个或多个 key-value 对：mset<br>返回所有(一个或多个)给定 key 的值：mget<br>将 key 中储存的数字值增1(key不存在,则初始化为0,再加1)：incr key<br>将 key 中储存的数字值减1(key不存在,则初始化为0,再减1)：decr key<br>自增多少：incrBy key num<br>自减多少：decrBy key num<h3 id="2-Key的命令"><a href="#2-Key的命令" class="headerlink" title="2. Key的命令"></a>2. Key的命令</h3>获取所有key列表：key *<br>删除key：del key<br>设置key的过期时间：expire key xx<br>查看key的过期时间：ttl key<br>选择库  默认16个数据库：select 0-15<br>清空整个redis服务器数据，所有的数据库全部清空：flushall<br>清除当前库，redis中默认有16个数据库，名称分别为0,1,2.。。15：flushdb<h3 id="3-List的命令"><a href="#3-List的命令" class="headerlink" title="3. List的命令"></a>3. List的命令</h3></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/08/10/Redis/" data-id="cjz96v1vl0008hktdcfobv4tv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-liunx" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/07/liunx/" class="article-date">
  <time datetime="2019-08-07T01:20:57.000Z" itemprop="datePublished">2019-08-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/07/liunx/">liunx</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>liunx操作系统的优点：<br>服务器：centos<br>个人环境：Ubuntu</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/08/07/liunx/" data-id="cjz96v1vw000ehktdkotekxv3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-maven-ssm" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/23/maven-ssm/" class="article-date">
  <time datetime="2019-07-23T01:02:16.000Z" itemprop="datePublished">2019-07-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/23/maven-ssm/">maven+ssm</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="maven多模块开发"><a href="#maven多模块开发" class="headerlink" title="maven多模块开发"></a>maven多模块开发</h1><p>多模块：把当前的项目拆分成多个模块</p>
<h1 id="idea集成svn"><a href="#idea集成svn" class="headerlink" title="idea集成svn"></a>idea集成svn</h1><h2 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h2><h1 id="Lucene"><a href="#Lucene" class="headerlink" title="Lucene"></a>Lucene</h1><p>全文搜索引擎框架：从全文数据中进行检索就叫全文搜索，基于文本的搜索<br>对纯文本进行检索<br>全文搜索特点：</p>
<pre><code>1. 搜索非常快
2. 只关注文本，不关注语义
3. 对于查询最终结果值进行高亮展示
4. 对一部分关键字进行截取
5. 相关度最高的排在最前面，官网中相关的网页排在最前面
</code></pre><p>62//3/35/85//33<br>数据结构：</p>
<pre><code>1. 结构化数据：就是数据库中对应的表
2. 非结构化数据：word，pdf，txt
3. 半结构化数据：xml，html 
</code></pre><h1 id="异构系统"><a href="#异构系统" class="headerlink" title="异构系统"></a>异构系统</h1><p>用不同语言搭建的架构就叫做异构系统<br>CXF：webservice提供的框架</p>
<h1 id="第三方登录"><a href="#第三方登录" class="headerlink" title="第三方登录"></a>第三方登录</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/23/maven-ssm/" data-id="cjz96v1w0000hhktdnfm2uusf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-MyBatis" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/19/MyBatis/" class="article-date">
  <time datetime="2019-07-19T01:04:27.000Z" itemprop="datePublished">2019-07-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/19/MyBatis/">MyBatis</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="ORM概述"><a href="#ORM概述" class="headerlink" title="ORM概述"></a>ORM概述</h1><h2 id="流行的ORM框架"><a href="#流行的ORM框架" class="headerlink" title="流行的ORM框架"></a>流行的ORM框架</h2><pre><code>1. jpa：本身是一种ORM规范，不是ORM框架，有各大ORM框架提供实现
</code></pre><h2 id="JDBC操作数据库缺陷"><a href="#JDBC操作数据库缺陷" class="headerlink" title="JDBC操作数据库缺陷"></a>JDBC操作数据库缺陷</h2><h1 id="MyBatis使用"><a href="#MyBatis使用" class="headerlink" title="MyBatis使用"></a>MyBatis使用</h1><ol>
<li>导包<pre><code>&lt;dependency&gt;
      &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
      &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
      &lt;version&gt;x.x.x&lt;/version&gt;
&lt;/dependency&gt;
</code></pre></li>
<li><p>XML配置文件<br> 创建一个XML配置文件，XML配置文件中包含了对MyBatis系统的核心设置，包含：</p>
<pre><code>1. 数据库连接实例的数据源(DataSource)
2. 决定事物作用域和控制方式的事务管理器(TransactionManager)
</code></pre><p> 当然，XML 配置文件还可以配置很多。<br> 下面给出一个示例：<br>&lt;?xml version=”1.0” encoding=”UTF-8” ?&gt;<br>`    &lt;!DOCTYPE configuration PUBLIC “-//mybatis.org//DTD Config 3.0//EN”</p>
<pre><code>&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
</code></pre><!--mybatis的根元素-->
<p><configuration><br> <properties resource="jdbc.properties"></properties></configuration></p>
 <!--给类型取别名-->
<p> <typealiases></typealiases></p>
<pre><code>&lt;!--
方式1:给每个类型取一个别名
&lt;typeAlias type=&quot;cn.itsource.mybatis._01hello.domain.Product&quot; alias=&quot;Product&quot;/&gt;
&lt;typeAlias type=&quot;cn.itsource.mybatis._01hello.domain.Customer&quot; alias=&quot;Customer&quot;/&gt;
&lt;typeAlias type=&quot;cn.itsource.mybatis._01hello.domain.Order&quot; alias=&quot;Order&quot;/&gt;
--&gt;
&lt;!--方式2: 所有的domain都得放在同一个地方--&gt;
&lt;package name=&quot;cn.itsource.domain&quot;/&gt;
</code></pre><p> </p>
 <!--配置环境(操作数据库的环境)-->
 <environments default="mysql"><br>     <environment id="mysql"><br>         <!--事务管理器,凡是用框架都有事务--><br>         <transactionmanager type="JDBC"><br>         <!--配置数据源(连接池)--><br>         <datasource type="POOLED"><br>             <property name="username" value="${jdbc.username}"><br>             <property name="password" value="${jdbc.password}"><br>             <property name="driver" value="${jdbc.driverClassName}"><br>             <property name="url" value="${jdbc.url}"><br>         </property></property></property></property></datasource><br>     </transactionmanager></environment><br> </environments>

 <!--引入多个mapper对象-->
<p> <mappers></mappers></p>
<pre><code>&lt;mapper resource=&quot;cn/itsource/dao/impl/ProductDaoImpl.xml&quot;/&gt;
</code></pre><p> <br>`</p>
</li>
</ol>
<p>mybatis提供的三大核心对象：</p>
<pre><code>1. SqlSessionFactoryBuilder主要用来创建SQLSessionFactory对象
2. SQLSessionFactory他是一个重量级对象，它是线程安全的所以在使用SQLSessionFactory时，不能随意销毁，因为创建它一次很不容易
</code></pre><h2 id="mapper映射器的使用"><a href="#mapper映射器的使用" class="headerlink" title="mapper映射器的使用"></a>mapper映射器的使用</h2><h1 id="MyBatis代码生成器"><a href="#MyBatis代码生成器" class="headerlink" title="MyBatis代码生成器"></a>MyBatis代码生成器</h1><h1 id="MyBatis拦截器"><a href="#MyBatis拦截器" class="headerlink" title="MyBatis拦截器"></a>MyBatis拦截器</h1><p>拦截器作用：拦截请求，织入自己额外的业务逻辑，增强功能<br>mybatis作为一个orm框架，它也给我们提供了一个拦截器，该拦截器主要是拦截你操作数据库的那一刻(操作数据库之前，之后，获取到结果值)<br>mybatis分页插件：底层基于拦截器实现</p>
<h1 id="SSM集成"><a href="#SSM集成" class="headerlink" title="SSM集成"></a>SSM集成</h1><ol>
<li>创建web项目</li>
<li>导入jar包</li>
<li>配置核心配置文件<ol>
<li>applicationContext.xml</li>
<li>jdbc.properties</li>
<li>dataSource</li>
<li>sqlSessionFactory</li>
<li>dao</li>
<li>service</li>
<li>controller</li>
<li></li>
</ol>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/19/MyBatis/" data-id="cjz96v1vh0005hktdpfsyo398" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-VUE" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/16/VUE/" class="article-date">
  <time datetime="2019-07-16T01:00:35.000Z" itemprop="datePublished">2019-07-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/16/VUE/">VUE</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Vue-js-是什么"><a href="#Vue-js-是什么" class="headerlink" title="Vue.js 是什么"></a>Vue.js 是什么</h1><p>Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p>
<h1 id="holle-word"><a href="#holle-word" class="headerlink" title="holle word!"></a>holle word!</h1><pre><code>&lt;script src=&quot;js/vue.min.js&quot;&gt;&lt;/script&gt;
&lt;div id=&quot;app&quot; &gt;
    &lt;!--hello vue!--&gt;
    {{message}}&lt;br/&gt;
&lt;/div&gt;
&lt;script&gt;
    new Vue({
            el:&quot;#app&quot;,
            data:{
                message:&quot;hello vue!&quot;
            }
    })
&lt;/script&gt;
</code></pre><h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><ol>
<li>创建组件方式一<br> //创建全局组件<br> Vue.component(“mycomponent”,{<pre><code>template:&quot;&lt;h1&gt;全局组件&lt;/h1&gt;&quot;
</code></pre> })<br> new Vue({<pre><code>el:&quot;#app&quot;,
components:{
    innercomponent:{
        template:&quot;&lt;h2&gt;局部组件&lt;/h2&gt;&quot;
    }
}
</code></pre> }) <div id="app"><br>     <mycomponent></mycomponent><br>     <innercomponent></innercomponent><br> </div></li>
<li>创建组件方式二 <template id="template"><br>     <h1>全局组件创建</h1><br> </template></li>
<li>创建组件方式三<br> <script type="text/template" id="template"><pre><code>&lt;h1&gt;全局组件创建&lt;/h1&gt;
</code></pre> </script><h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1></li>
<li>什么是路由<br> 路由是负责将进入的浏览器请求映射到特定的组件代码中，即决定了由谁去响应客户端请求</li>
<li>使用路由的步骤<ol>
<li>导入路由的js库</li>
<li>准备路径</li>
<li>准备组件</li>
<li>做一个路径映射到组件的配置</li>
<li>告诉vue我要使用路由</li>
<li>最终组件展示的位置<h1 id="ElementUI"><a href="#ElementUI" class="headerlink" title="ElementUI"></a>ElementUI</h1></li>
</ol>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/16/VUE/" data-id="cjz96v1vm0009hktdili6n337" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-面试题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/14/面试题/" class="article-date">
  <time datetime="2019-07-14T01:02:57.000Z" itemprop="datePublished">2019-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/14/面试题/">面试题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li>forword和redirect的区别以及各自的应用场景<br> forword请求转发，redirect重定向<br> 区别：<pre><code>1. forward是一个请求的延续，可以共享request的数据，redirect开启一个新的请求，不可以共享request
2. forward地址栏不发生变化，redirect地址栏发生变化
3. forward是发送一次请求，redirect是发送两次请求
4. forward不能跨域访问，redirect能跨域访问
5. forward请求能访问WEB-inf下main的资源
</code></pre> 应用场景<br> forward一般用于用户登录的时候，根据角色转发到相应的模块<br> redirect一般用于用户注销登录时返回主页面和跳转到其他的网站等</li>
<li>为什么要进行事务管理,Spring是如何进行事务管理支持的<br> 防止出现脏数据，防止数据库数据出现问题<br> spring是通过“声明式事务(基于AOP)”的方式对事务进行管理，即在配置文件中进行声明</li>
<li>解释一下DI依赖注入和IOC控制反转，Spring中是如何做的</li>
<li>Spring中的BeanFactory与ApplicationContext的区别</li>
<li>什么是aop，aop的作用是什么</li>
<li>GET与POST的区别，分别用在什么场景合适？</li>
<li>什么是单例模式，有哪些实现方式，写出其中两种</li>
<li>数据库储存引擎myisam / innodb的区别</li>
<li>模糊查询可以使用索引吗？</li>
<li>索引的优缺点</li>
<li>介绍一下hibernate的缓存机制</li>
<li>请描述一下springMvc执行流程<ol>
<li>客户端发送请求通过springMVC的核心控制器</li>
</ol>
</li>
<li>Servlet的生命周期</li>
<li>Jsp九大内置对象</li>
<li>自我介绍</li>
<li>请谈谈你最近做的一个项目</li>
<li>你主要负责的模块有哪些</li>
<li>Sleep与wait的区别</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/14/面试题/" data-id="cjz96v1w2000jhktd6z44ku04" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-（Spring+SpringDataJPA+SpringMVC+EasyUI+Maven)-智能商贸" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/27/（Spring+SpringDataJPA+SpringMVC+EasyUI+Maven)-智能商贸/" class="article-date">
  <time datetime="2019-06-27T01:21:28.000Z" itemprop="datePublished">2019-06-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/27/（Spring+SpringDataJPA+SpringMVC+EasyUI+Maven)-智能商贸/">智能商贸——进销存系统</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h1><ol>
<li>这个项目是干什么的<br> 对企业生产经营中进货、出货、批发销售、付款等进行全程进行（从接获订单合同开始，进入物料采购、入库、领用到产品完工入库、交货、回收货款、支付原材料款等）跟踪（每一步都提供详尽准确的数据）、管理（有效辅助企业解决业务管理、分销管理、存货管理、营销计划的执行和监控、统计信息的收集等方面的业务问题）而设计的整套方案</li>
<li>项目用到哪些技术<br> spring+springMVC+springDataJpa+shiro+easyui+easypoi+maven+hightchart+idea</li>
<li><p>模块</p>
<ol>
<li>基础模块(用户管理，产品模块，数据字典，客户管理…)</li>
<li>权限模块(shiro)</li>
<li>登录模块(第三方登录，自动登录，限制登录人数，手机登录，忘记密码…)</li>
<li>采购模块</li>
<li>报表模块(多张表进行连表查询最终做的统计)</li>
<li>库存模块<h1 id="SpringDataJpa"><a href="#SpringDataJpa" class="headerlink" title="SpringDataJpa"></a>SpringDataJpa</h1>spring在jpa基础上又做了一层封装让你做crud更加简单<h1 id="sssdj的集成步骤"><a href="#sssdj的集成步骤" class="headerlink" title="sssdj的集成步骤"></a>sssdj的集成步骤</h1></li>
<li>创建web项目</li>
<li>导入相应的jar包</li>
<li>配置ApplicationContext.xml文件<ol>
<li>编写jdbc.properties</li>
<li>DataSource</li>
<li>EntityManagerFactory<ol>
<li>依赖dataSource</li>
<li>扫描domain包</li>
<li>具体实现的框架<br> 方言<br> 是否显示sql<br> 建表策略</li>
</ol>
</li>
</ol>
</li>
<li>springMvc的核心配置<ol>
<li>扫描controller包</li>
<li>开启springMvc注解支持</li>
<li>静态资源放行</li>
<li>视图解析器</li>
</ol>
</li>
<li>web.xml<ol>
<li>启动spring容器</li>
<li>启动springMvc容器</li>
<li>解决post提交乱码问题<h1 id="完成domain层"><a href="#完成domain层" class="headerlink" title="完成domain层"></a>完成domain层</h1><h1 id="Velocity模板技术"><a href="#Velocity模板技术" class="headerlink" title="Velocity模板技术"></a>Velocity模板技术</h1><h2 id="EasyCode"><a href="#EasyCode" class="headerlink" title="EasyCode"></a>EasyCode</h2>EasyCode是基于IntelliJ IDEA Ultimate版开发的一个代码生成插件，主要通过自定义模板（基于velocity）来生成各种你想要的代码。通常用于生成Entity、Dao、Service、Controller。如果你动手能力强还可以用于生成HTML、JS、PHP等代码。理论上来说只要是与数据有关的代码都是可以生成的。<h1 id="shiro"><a href="#shiro" class="headerlink" title="shiro"></a>shiro</h1>shiro：shiro是一个强大易用的java安全框架<br>常见的权限框架</li>
</ol>
</li>
<li>spring security<ol>
<li>是spring公司的产品，它功能非常强大，属于重量级框架，提供的API文档非常丰富</li>
</ol>
</li>
<li>shiro<ol>
<li>是Apache公司的产品，属于轻量级框架<br>shiro四大核心</li>
</ol>
</li>
<li>身份认证：登录</li>
<li>授权：给当前登录人，授予角色和权限</li>
<li>密码学：指的就是对你的密码进行加密</li>
<li>session管理：shiro提供的session功能非常强大，不仅可以用于Bs架构还可以用于Cs架构，如果你把数据存储到shiro的session中它会自动同步到你的HttpSession中，shiro还可以对session进行crud<br>使用shiro</li>
<li>导入jar包<!-- shiro的支持包 -->
<dependency><br><groupid>org.apache.shiro</groupid><br><artifactid>shiro-all</artifactid><br><version>1.4.0</version><br><type>pom</type><br></dependency><br><!-- shiro与Spring的集成包 --><br><dependency><br><groupid>org.apache.shiro</groupid><br><artifactid>shiro-spring</artifactid><br><version>1.4.0</version><br></dependency></li>
<li><p>创建shiro配置<br> &lt;?xml version=”1.0” encoding=”UTF-8”?&gt;</p>
<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"><br><!--shiro的核心对象--><br><bean id="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager"><br> <property name="realm" ref="itsourceRealm"><br></property></bean><br><!--自定义realm--><br><bean id="itsourceRealm" class="com.sunlei.aisell.realm.ItsourceRealm"><br> <property name="credentialsMatcher"><br>     <bean class="org.apache.shiro.authc.credential.HashedCredentialsMatcher"><br>         <property name="hashAlgorithmName" value="MD5"><br>         <property name="hashIterations" value="10"><br>     </property></property></bean><br> </property><br></bean><br><!--
 处理    代理过滤器拦截的所有请求
 注意事项:该bean的id必须要和代理过滤器的name一致,否则报错
--><br><bean id="shiroFilter" class="org.apache.shiro.spring.web.ShiroFilterFactoryBean"><br> <property name="securityManager" ref="securityManager"><br> <!-- 如果你的请求,没有认证或者没有认证通过,或者注销之后,都跳转到loginUrl对应的请求中--><br> <property name="loginUrl" value="/s/login.jsp"><br> <!--登录成功之后,跳转到successUrl对应的路径中--><br> <property name="successUrl" value="/s/index"><br><br> <!--没有权限都跳转到unauthorizedUrl对应的路径中--><br> <property name="unauthorizedUrl" value="/s/unauthorized.jsp"><br><br> <!--过滤器链的定义--><br> <property name="filterChainDefinitions"><br>     <value><br>         <!--直接放行不进行拦截--><br>         /s/login.jsp = anon<br>         /login=anon<br>         /logout=logout<br>         /dept/index=perms[“dept:index”]<br>         /dept/save=perms[“dept:save”]<br>         /dept/delete=perms[“dept:delete”]<br>         /dept/update=perms[“dept:update”]<br>         /permission/index=perms[“permission:index”]<br>         <!--
         /*与/**的区别:
                  /* 表示拦截所有的请求,你的请求只能拦截一级,多级无法拦截
                  /**:表示拦截所有的请求,你的请求1级或者多级都可以正常拦截
                authc:认证通过之后才能放行
                anon:匿名过滤器,直接放行
                logout:注销
          --><br>         /** = authc<br>     </value><br> </property><br></property></property></property></property></bean><br></beans></li>
<li>自定义realm</li>
<li>创建MD5工具类</li>
</ol>
</li>
</ol>
<pre><code>3. 集成spring

shiroMD5加密        

    登录时用密码匹配器
</code></pre><h1 id="java操作办公软件：word-ppt-excel-pdf"><a href="#java操作办公软件：word-ppt-excel-pdf" class="headerlink" title="java操作办公软件：word ppt excel pdf"></a>java操作办公软件：word ppt excel pdf</h1><p>easypoi</p>
<h1 id="数据字典"><a href="#数据字典" class="headerlink" title="数据字典"></a>数据字典</h1><p>简单理解就是对表的抽取<br>在真实开发项目中，我们会遇到很多基础表，这些基础表都有一个公共的特性：</p>
<pre><code>1. 字段非常少
2. 数据也非常少
</code></pre><p>使用数据字典的注意事项：</p>
<pre><code>1. 字段必须得少，最多三个字段
2. 如果该表存在，上下级关系也是不能用数据字典
3. 数据量不能过大，最多不超过20个以上
</code></pre><h1 id="图形化界面报表"><a href="#图形化界面报表" class="headerlink" title="图形化界面报表"></a>图形化界面报表</h1><ol>
<li>html5<ol>
<li>优点：占用带宽小，稳定</li>
<li>缺点：兼容性差(IE8以下是不能使用html5)</li>
</ol>
</li>
<li>flash<ol>
<li>优点：市面上基本上所有的浏览器都兼容</li>
<li>缺点：占用带宽大，不稳定<br>专门做图形化界面的插件：</li>
<li>ECharts</li>
<li>HightCharts<h1 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h1><h1 id="发送邮件"><a href="#发送邮件" class="headerlink" title="发送邮件"></a>发送邮件</h1></li>
</ol>
</li>
</ol>
<h1 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h1><h2 id="easyUi分页数据只展示第一页"><a href="#easyUi分页数据只展示第一页" class="headerlink" title="easyUi分页数据只展示第一页"></a>easyUi分页数据只展示第一页</h2><p>query里面加两个方法<br>    public void setPage(Integer page){<br>        this.currentPage=page;<br>    }<br>    public void  setRows(Integer rows){<br>        this.pageSize=rows;<br>    }</p>
<h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><h2 id="登录页面"><a href="#登录页面" class="headerlink" title="登录页面"></a>登录页面</h2><pre><code>1. 登录页面
2. 根据用户名动态显示头像 类似QQ登陆

//实时展示头像
$(function ($) {
    //1.校验用户输入的是正则表达式 先定义正则
    var emailFormat = /^[a-zA-Z0-9]/;
    // var flag = &apos;true&apos;;
    //2.当失去用户焦点的时候校验用户名
    var lastvalue = null;
    $(&apos;#user&apos;).on(&apos;blur&apos;, function () {
        //获取用户输入内容
        var value = $(this).val();
        if (!value || !emailFormat.test(value)) return;
        if (value !== lastvalue) {
            // 接下来需要通过用户名找到对应的头像地址，然后将头像地址改到img的src上
            $.get(&apos;/headImage&apos;, {name: value}, function (res) {
                if (!res) {
                    $(&apos;.avatar&apos;).fadeOut(function () {
                        $(this).on(&apos;load&apos;, function () {
                            $(this).fadeIn()
                        }).attr(&apos;src&apos;, &quot;&quot;);
                    })
                    $(&quot;#spanshow1&quot;).show()
                    $(&quot;#spanshow2&quot;).show()
                    return;
                }
hideSpan()
                $(&apos;.avatar&apos;).fadeOut(function () {
                    $(this).on(&apos;load&apos;, function () {
                        $(this).fadeIn()
                    }).attr(&apos;src&apos;, res);
                })

                // flag = false;
                // $(&apos;.avatar&apos;).fadeOut(function () {
                //   $(this).on(&apos;load&apos;,function () {
                //     $this.fadeIn();
                //   }).attr(&apos;src&apos;, res);
                // })
            })
        }
        lastvalue = value;
    })

})

3. 记住密码cookie

 saveCookie(){ //设置cookie
    var username = $(&quot;#user&quot;).val(); //获取用户名信息
    var password = $(&quot;#passwd&quot;).val(); //获取登陆密码信息
    var  img = $(&quot;#head&quot;).attr(&apos;src&apos;);
    console.debug(111)
    var checked = $(&apos;#brand1&apos;).val()//获取“是否记住密码”复选框
    if(checked==1){ //判断是否选中了“记住密码”复选框
        $.cookie(&quot;username&quot;,username);//调用jquery.cookie.js中的方法设置cookie中的用户名    
        $.cookie(&quot;password&quot;,$.base64.encode(password));//调用jquery.cookie.js中的方法设置cookie中的登陆密码，并使用base64（jquery.base64.js）进行加密    
        $.cookie(&quot;img&quot;,img);//调用jquery.cookie.js中的方法设置cookie中的登陆密码，并使用base64（jquery.base64.js）进行加密    
    }else{
        //$.cookie(&quot;password&quot;, null);
    }
}
function getCookie(){ //获取cookie    
    var username = $.cookie(&quot;username&quot;); //获取cookie中的用户名    
    var password =  $.cookie(&quot;password&quot;); //获取cookie中的登陆密码
    var  img = $.cookie(&quot;img&quot;);
    console.debug(img)
    if(password){//密码存在的话把“记住用户名和密码”复选框勾选住   
        $(&quot;#remberme&quot;).click();
    }
    if(username){//用户名存在的话把用户名填充到用户名文本框    
        $(&quot;#user&quot;).val(username);
    }
    if(password){//密码存在的话把密码填充到密码文本框    
        $(&quot;#passwd&quot;).val($.base64.decode(password));
    }
    if(img){//密码存在的话把密码填充到密码文本框    
        hideSpan()
        $(&quot;#head&quot;).attr(&quot;src&quot;,img)
    }
}
//清除cookie
function clearCookie(name) {
    $.cookie(name, &quot;&quot;, -1);
}
if ($.cookie(&quot;password&quot;)){
    getCookie()
}

4. 提示---display，opacity属性
</code></pre><h2 id="主页"><a href="#主页" class="headerlink" title="主页"></a>主页</h2><pre><code>1. 显示登录用户圆形头像
    .loginUser img{
        width: 50px;
        height: 50px;
        display: flex;
        border-radius: 50%;
        align-items: center;
        justify-content: center;
        overflow: hidden;
    }
2. 拖动标签页
3. 标签页右键菜单
</code></pre><h2 id="标签页面"><a href="#标签页面" class="headerlink" title="标签页面"></a>标签页面</h2><pre><code>1. 添加数据完成时跳到添加数据位置
2. 右键菜单
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/27/（Spring+SpringDataJPA+SpringMVC+EasyUI+Maven)-智能商贸/" data-id="cjz96v1wb000lhktd1079jknt" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-spring" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/24/spring/" class="article-date">
  <time datetime="2019-06-24T01:26:23.757Z" itemprop="datePublished">2019-06-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>title: spring<br>date: 2019-06-24 09:26:23</p>
<h2 id="tags"><a href="#tags" class="headerlink" title="tags:"></a>tags:</h2><h1 id="spring的核心"><a href="#spring的核心" class="headerlink" title="spring的核心"></a>spring的核心</h1><pre><code>1. IOC/DI：IOC指的是控制反转，所谓控制反转指的就是把所有的bean对象，交给spring容器进行管理，由spring统一来创建bean对象，这种创建对象的权利反转就叫做控制反转
2. AOP：面向切面编程，在你指定的service层，执行前或者执行后切一刀，然后织入自己的业务逻辑，能有效的进行解耦
3. AOP有什么作用：
    1. 抽取公共的业务逻辑代码
    2. 扩展功能
    3. 权限
    4. 日志

AOP底层是基于代理模式实现的：
    1. JDK动态代理：前提，你的目标类必须提供了一个接口，否则不能代理
    2. CGLIB动态代理：他可以代理的类，有实现接口，也可以没有实现接口
</code></pre><h1 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h1><h1 id="XML自动注入"><a href="#XML自动注入" class="headerlink" title="XML自动注入"></a>XML自动注入</h1><h1 id="全注解配置"><a href="#全注解配置" class="headerlink" title="全注解配置"></a>全注解配置</h1><p>@Autowired与@Resource的区别</p>
<pre><code>1. 都是注入bean对象
2. @Autowired是spring提供的注解，@Resource是sun公司提供的注解
3. @Autowired注入bean的时候，是先根据类型注入，再根据名字注入
4. 推荐使用@Autowired，@Autowired是spring公司的，与spring无缝衔接
</code></pre><h2 id="spring创建Bean的4中方式"><a href="#spring创建Bean的4中方式" class="headerlink" title="spring创建Bean的4中方式"></a>spring创建Bean的4中方式</h2><pre><code>1. &lt;bean class=&quot;类的全限定名&quot;/&gt;相当于java中的new 类名();
2. 使用FactoryBean来创建 FactoryBean专门创建复杂的对象
    1. 自定义类实现FactoryBean
    2. 复写3个抽象方法
        1. 是否单例
</code></pre><h3 id="BeanFactory和ApplicationContext的区别"><a href="#BeanFactory和ApplicationContext的区别" class="headerlink" title="BeanFactory和ApplicationContext的区别"></a>BeanFactory和ApplicationContext的区别</h3><pre><code>1. BeanFactory它是一个bean工厂，专门负责创建与管理所有的bean对象
2. BeanFactory它是要运行的时候才会去创建Bean对象，而ApplicationContext是BeanFactory的子接口
3. 而ApplicationContext是加载配置文件的时候，就会去创建对应的bean对象，所以以后我们都用ApplicationContext
</code></pre><h1 id="ssj的集成步骤"><a href="#ssj的集成步骤" class="headerlink" title="ssj的集成步骤"></a>ssj的集成步骤</h1><pre><code>1. 创建web项目
2. 导入相应的jar包
3. 配置ApplicationContext.xml文件
    1. 编写jdbc.properties
    2. DataSource
    3. EntityManagerFactory
        1. 依赖dataSource
        2. 扫描domain包
        3. 具体实现的框架
            方言
            是否显示sql
            建表策略
4. springMvc的核心配置
    1. 扫描controller包
    2. 开启springMvc注解支持
    3. 静态资源放行
    4. 视图解析器
5. web.xml
    1. 启动spring容器
    2. 启动springMvc容器
    3. 解决post提交乱码问题
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/24/spring/" data-id="cjz96v1w3000khktdx6qswms0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/08/13/springboot/">springboot</a>
          </li>
        
          <li>
            <a href="/2019/08/11/Elasticsearch/">ElasticSearch</a>
          </li>
        
          <li>
            <a href="/2019/08/10/Redis/">Redis</a>
          </li>
        
          <li>
            <a href="/2019/08/07/liunx/">liunx</a>
          </li>
        
          <li>
            <a href="/2019/07/23/maven-ssm/">maven+ssm</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 sunlei<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>