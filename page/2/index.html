<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>java学习笔记</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="java学习笔记">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="java学习笔记">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java学习笔记">
  
    <link rel="alternate" href="/atom.xml" title="java学习笔记" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">java学习笔记</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-maven-ssm" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/23/maven-ssm/" class="article-date">
  <time datetime="2019-07-23T01:02:16.000Z" itemprop="datePublished">2019-07-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/23/maven-ssm/">maven+ssm</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="maven多模块开发"><a href="#maven多模块开发" class="headerlink" title="maven多模块开发"></a>maven多模块开发</h1><p>多模块：把当前的项目拆分成多个模块</p>
<h1 id="idea集成svn"><a href="#idea集成svn" class="headerlink" title="idea集成svn"></a>idea集成svn</h1><h2 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h2><h1 id="Lucene"><a href="#Lucene" class="headerlink" title="Lucene"></a>Lucene</h1><p>全文搜索引擎框架：从全文数据中进行检索就叫全文搜索，基于文本的搜索<br>对纯文本进行检索<br>全文搜索特点：</p>
<pre><code>1. 搜索非常快
2. 只关注文本，不关注语义
3. 对于查询最终结果值进行高亮展示
4. 对一部分关键字进行截取
5. 相关度最高的排在最前面，官网中相关的网页排在最前面
</code></pre><p>62//3/35/85//33<br>数据结构：</p>
<pre><code>1. 结构化数据：就是数据库中对应的表
2. 非结构化数据：word，pdf，txt
3. 半结构化数据：xml，html 
</code></pre><h1 id="异构系统"><a href="#异构系统" class="headerlink" title="异构系统"></a>异构系统</h1><p>用不同语言搭建的架构就叫做异构系统<br>CXF：webservice提供的框架</p>
<h1 id="第三方登录"><a href="#第三方登录" class="headerlink" title="第三方登录"></a>第三方登录</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/23/maven-ssm/" data-id="cjzoty7r6000nigtdc7l2t8rf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-MyBatis" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/19/MyBatis/" class="article-date">
  <time datetime="2019-07-19T01:04:27.000Z" itemprop="datePublished">2019-07-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/19/MyBatis/">MyBatis</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="ORM概述"><a href="#ORM概述" class="headerlink" title="ORM概述"></a>ORM概述</h1><h2 id="流行的ORM框架"><a href="#流行的ORM框架" class="headerlink" title="流行的ORM框架"></a>流行的ORM框架</h2><pre><code>1. jpa：本身是一种ORM规范，不是ORM框架，有各大ORM框架提供实现
</code></pre><h2 id="JDBC操作数据库缺陷"><a href="#JDBC操作数据库缺陷" class="headerlink" title="JDBC操作数据库缺陷"></a>JDBC操作数据库缺陷</h2><h1 id="MyBatis使用"><a href="#MyBatis使用" class="headerlink" title="MyBatis使用"></a>MyBatis使用</h1><ol>
<li>导包<pre><code>&lt;dependency&gt;
      &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
      &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
      &lt;version&gt;x.x.x&lt;/version&gt;
&lt;/dependency&gt;
</code></pre></li>
<li><p>XML配置文件<br> 创建一个XML配置文件，XML配置文件中包含了对MyBatis系统的核心设置，包含：</p>
<pre><code>1. 数据库连接实例的数据源(DataSource)
2. 决定事物作用域和控制方式的事务管理器(TransactionManager)
</code></pre><p> 当然，XML 配置文件还可以配置很多。<br> 下面给出一个示例：<br>&lt;?xml version=”1.0” encoding=”UTF-8” ?&gt;<br>`    &lt;!DOCTYPE configuration PUBLIC “-//mybatis.org//DTD Config 3.0//EN”</p>
<pre><code>&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
</code></pre><!--mybatis的根元素-->
<p><configuration><br> <properties resource="jdbc.properties"></properties></configuration></p>
 <!--给类型取别名-->
<p> <typealiases></typealiases></p>
<pre><code>&lt;!--
方式1:给每个类型取一个别名
&lt;typeAlias type=&quot;cn.itsource.mybatis._01hello.domain.Product&quot; alias=&quot;Product&quot;/&gt;
&lt;typeAlias type=&quot;cn.itsource.mybatis._01hello.domain.Customer&quot; alias=&quot;Customer&quot;/&gt;
&lt;typeAlias type=&quot;cn.itsource.mybatis._01hello.domain.Order&quot; alias=&quot;Order&quot;/&gt;
--&gt;
&lt;!--方式2: 所有的domain都得放在同一个地方--&gt;
&lt;package name=&quot;cn.itsource.domain&quot;/&gt;
</code></pre><p> </p>
 <!--配置环境(操作数据库的环境)-->
 <environments default="mysql"><br>     <environment id="mysql"><br>         <!--事务管理器,凡是用框架都有事务--><br>         <transactionmanager type="JDBC"><br>         <!--配置数据源(连接池)--><br>         <datasource type="POOLED"><br>             <property name="username" value="${jdbc.username}"><br>             <property name="password" value="${jdbc.password}"><br>             <property name="driver" value="${jdbc.driverClassName}"><br>             <property name="url" value="${jdbc.url}"><br>         </property></property></property></property></datasource><br>     </transactionmanager></environment><br> </environments>

 <!--引入多个mapper对象-->
<p> <mappers></mappers></p>
<pre><code>&lt;mapper resource=&quot;cn/itsource/dao/impl/ProductDaoImpl.xml&quot;/&gt;
</code></pre><p> <br>`</p>
</li>
</ol>
<p>mybatis提供的三大核心对象：</p>
<pre><code>1. SqlSessionFactoryBuilder主要用来创建SQLSessionFactory对象
2. SQLSessionFactory他是一个重量级对象，它是线程安全的所以在使用SQLSessionFactory时，不能随意销毁，因为创建它一次很不容易
</code></pre><h2 id="mapper映射器的使用"><a href="#mapper映射器的使用" class="headerlink" title="mapper映射器的使用"></a>mapper映射器的使用</h2><h1 id="MyBatis代码生成器"><a href="#MyBatis代码生成器" class="headerlink" title="MyBatis代码生成器"></a>MyBatis代码生成器</h1><h1 id="MyBatis拦截器"><a href="#MyBatis拦截器" class="headerlink" title="MyBatis拦截器"></a>MyBatis拦截器</h1><p>拦截器作用：拦截请求，织入自己额外的业务逻辑，增强功能<br>mybatis作为一个orm框架，它也给我们提供了一个拦截器，该拦截器主要是拦截你操作数据库的那一刻(操作数据库之前，之后，获取到结果值)<br>mybatis分页插件：底层基于拦截器实现</p>
<h1 id="SSM集成"><a href="#SSM集成" class="headerlink" title="SSM集成"></a>SSM集成</h1><ol>
<li>创建web项目</li>
<li>导入jar包</li>
<li>配置核心配置文件<ol>
<li>applicationContext.xml</li>
<li>jdbc.properties</li>
<li>dataSource</li>
<li>sqlSessionFactory</li>
<li>dao</li>
<li>service</li>
<li>controller</li>
<li></li>
</ol>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/19/MyBatis/" data-id="cjzoty7qn0007igtdgf1u1ujt" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-VUE" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/16/VUE/" class="article-date">
  <time datetime="2019-07-16T01:00:35.000Z" itemprop="datePublished">2019-07-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/16/VUE/">VUE</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Vue-js-是什么"><a href="#Vue-js-是什么" class="headerlink" title="Vue.js 是什么"></a>Vue.js 是什么</h1><p>Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p>
<h1 id="holle-word"><a href="#holle-word" class="headerlink" title="holle word!"></a>holle word!</h1><pre><code>&lt;script src=&quot;js/vue.min.js&quot;&gt;&lt;/script&gt;
&lt;div id=&quot;app&quot; &gt;
    &lt;!--hello vue!--&gt;
    {{message}}&lt;br/&gt;
&lt;/div&gt;
&lt;script&gt;
    new Vue({
            el:&quot;#app&quot;,
            data:{
                message:&quot;hello vue!&quot;
            }
    })
&lt;/script&gt;
</code></pre><h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><ol>
<li>创建组件方式一<br> //创建全局组件<br> Vue.component(“mycomponent”,{<pre><code>template:&quot;&lt;h1&gt;全局组件&lt;/h1&gt;&quot;
</code></pre> })<br> new Vue({<pre><code>el:&quot;#app&quot;,
components:{
    innercomponent:{
        template:&quot;&lt;h2&gt;局部组件&lt;/h2&gt;&quot;
    }
}
</code></pre> }) <div id="app"><br>     <mycomponent></mycomponent><br>     <innercomponent></innercomponent><br> </div></li>
<li>创建组件方式二 <template id="template"><br>     <h1>全局组件创建</h1><br> </template></li>
<li>创建组件方式三<br> <script type="text/template" id="template"><pre><code>&lt;h1&gt;全局组件创建&lt;/h1&gt;
</code></pre> </script><h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1></li>
<li>什么是路由<br> 路由是负责将进入的浏览器请求映射到特定的组件代码中，即决定了由谁去响应客户端请求</li>
<li>使用路由的步骤<ol>
<li>导入路由的js库</li>
<li>准备路径</li>
<li>准备组件</li>
<li>做一个路径映射到组件的配置</li>
<li>告诉vue我要使用路由</li>
<li>最终组件展示的位置<h1 id="ElementUI"><a href="#ElementUI" class="headerlink" title="ElementUI"></a>ElementUI</h1></li>
</ol>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/16/VUE/" data-id="cjzoty7r1000higtdfb7v29ep" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-面试题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/14/面试题/" class="article-date">
  <time datetime="2019-07-14T01:02:57.000Z" itemprop="datePublished">2019-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/14/面试题/">面试题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li>forword和redirect的区别以及各自的应用场景<br> forword请求转发，redirect重定向<br> 区别：<pre><code>1. forward是一个请求的延续，可以共享request的数据，redirect开启一个新的请求，不可以共享request
2. forward地址栏不发生变化，redirect地址栏发生变化
3. forward是发送一次请求，redirect是发送两次请求
4. forward不能跨域访问，redirect能跨域访问
5. forward请求能访问WEB-inf下main的资源
</code></pre> 应用场景<br> forward一般用于用户登录的时候，根据角色转发到相应的模块<br> redirect一般用于用户注销登录时返回主页面和跳转到其他的网站等</li>
<li>为什么要进行事务管理,Spring是如何进行事务管理支持的<br> 防止出现脏数据，防止数据库数据出现问题<br> spring是通过“声明式事务(基于AOP)”的方式对事务进行管理，即在配置文件中进行声明</li>
<li>解释一下DI依赖注入和IOC控制反转，Spring中是如何做的</li>
<li>Spring中的BeanFactory与ApplicationContext的区别</li>
<li>什么是aop，aop的作用是什么</li>
<li>GET与POST的区别，分别用在什么场景合适？</li>
<li>什么是单例模式，有哪些实现方式，写出其中两种</li>
<li>数据库储存引擎myisam / innodb的区别</li>
<li>模糊查询可以使用索引吗？</li>
<li>索引的优缺点</li>
<li>介绍一下hibernate的缓存机制</li>
<li>请描述一下springMvc执行流程<ol>
<li>客户端发送请求通过springMVC的核心控制器</li>
</ol>
</li>
<li>Servlet的生命周期</li>
<li>Jsp九大内置对象</li>
<li>自我介绍</li>
<li>请谈谈你最近做的一个项目</li>
<li>你主要负责的模块有哪些</li>
<li>Sleep与wait的区别</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/14/面试题/" data-id="cjzoty7r4000ligtdjdbmi0pg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-（Spring+SpringDataJPA+SpringMVC+EasyUI+Maven)-智能商贸" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/27/（Spring+SpringDataJPA+SpringMVC+EasyUI+Maven)-智能商贸/" class="article-date">
  <time datetime="2019-06-27T01:21:28.000Z" itemprop="datePublished">2019-06-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/27/（Spring+SpringDataJPA+SpringMVC+EasyUI+Maven)-智能商贸/">智能商贸——进销存系统</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h1><ol>
<li>这个项目是干什么的<br> 对企业生产经营中进货、出货、批发销售、付款等进行全程进行（从接获订单合同开始，进入物料采购、入库、领用到产品完工入库、交货、回收货款、支付原材料款等）跟踪（每一步都提供详尽准确的数据）、管理（有效辅助企业解决业务管理、分销管理、存货管理、营销计划的执行和监控、统计信息的收集等方面的业务问题）而设计的整套方案</li>
<li>项目用到哪些技术<br> spring+springMVC+springDataJpa+shiro+easyui+easypoi+maven+hightchart+idea</li>
<li><p>模块</p>
<ol>
<li>基础模块(用户管理，产品模块，数据字典，客户管理…)</li>
<li>权限模块(shiro)</li>
<li>登录模块(第三方登录，自动登录，限制登录人数，手机登录，忘记密码…)</li>
<li>采购模块</li>
<li>报表模块(多张表进行连表查询最终做的统计)</li>
<li>库存模块<h1 id="SpringDataJpa"><a href="#SpringDataJpa" class="headerlink" title="SpringDataJpa"></a>SpringDataJpa</h1>spring在jpa基础上又做了一层封装让你做crud更加简单<h1 id="sssdj的集成步骤"><a href="#sssdj的集成步骤" class="headerlink" title="sssdj的集成步骤"></a>sssdj的集成步骤</h1></li>
<li>创建web项目</li>
<li>导入相应的jar包</li>
<li>配置ApplicationContext.xml文件<ol>
<li>编写jdbc.properties</li>
<li>DataSource</li>
<li>EntityManagerFactory<ol>
<li>依赖dataSource</li>
<li>扫描domain包</li>
<li>具体实现的框架<br> 方言<br> 是否显示sql<br> 建表策略</li>
</ol>
</li>
</ol>
</li>
<li>springMvc的核心配置<ol>
<li>扫描controller包</li>
<li>开启springMvc注解支持</li>
<li>静态资源放行</li>
<li>视图解析器</li>
</ol>
</li>
<li>web.xml<ol>
<li>启动spring容器</li>
<li>启动springMvc容器</li>
<li>解决post提交乱码问题<h1 id="完成domain层"><a href="#完成domain层" class="headerlink" title="完成domain层"></a>完成domain层</h1><h1 id="Velocity模板技术"><a href="#Velocity模板技术" class="headerlink" title="Velocity模板技术"></a>Velocity模板技术</h1><h2 id="EasyCode"><a href="#EasyCode" class="headerlink" title="EasyCode"></a>EasyCode</h2>EasyCode是基于IntelliJ IDEA Ultimate版开发的一个代码生成插件，主要通过自定义模板（基于velocity）来生成各种你想要的代码。通常用于生成Entity、Dao、Service、Controller。如果你动手能力强还可以用于生成HTML、JS、PHP等代码。理论上来说只要是与数据有关的代码都是可以生成的。<h1 id="shiro"><a href="#shiro" class="headerlink" title="shiro"></a>shiro</h1>shiro：shiro是一个强大易用的java安全框架<br>常见的权限框架</li>
</ol>
</li>
<li>spring security<ol>
<li>是spring公司的产品，它功能非常强大，属于重量级框架，提供的API文档非常丰富</li>
</ol>
</li>
<li>shiro<ol>
<li>是Apache公司的产品，属于轻量级框架<br>shiro四大核心</li>
</ol>
</li>
<li>身份认证：登录</li>
<li>授权：给当前登录人，授予角色和权限</li>
<li>密码学：指的就是对你的密码进行加密</li>
<li>session管理：shiro提供的session功能非常强大，不仅可以用于Bs架构还可以用于Cs架构，如果你把数据存储到shiro的session中它会自动同步到你的HttpSession中，shiro还可以对session进行crud<br>使用shiro</li>
<li>导入jar包<!-- shiro的支持包 -->
<dependency><br><groupid>org.apache.shiro</groupid><br><artifactid>shiro-all</artifactid><br><version>1.4.0</version><br><type>pom</type><br></dependency><br><!-- shiro与Spring的集成包 --><br><dependency><br><groupid>org.apache.shiro</groupid><br><artifactid>shiro-spring</artifactid><br><version>1.4.0</version><br></dependency></li>
<li><p>创建shiro配置<br> &lt;?xml version=”1.0” encoding=”UTF-8”?&gt;</p>
<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"><br><!--shiro的核心对象--><br><bean id="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager"><br> <property name="realm" ref="itsourceRealm"><br></property></bean><br><!--自定义realm--><br><bean id="itsourceRealm" class="com.sunlei.aisell.realm.ItsourceRealm"><br> <property name="credentialsMatcher"><br>     <bean class="org.apache.shiro.authc.credential.HashedCredentialsMatcher"><br>         <property name="hashAlgorithmName" value="MD5"><br>         <property name="hashIterations" value="10"><br>     </property></property></bean><br> </property><br></bean><br><!--
 处理    代理过滤器拦截的所有请求
 注意事项:该bean的id必须要和代理过滤器的name一致,否则报错
--><br><bean id="shiroFilter" class="org.apache.shiro.spring.web.ShiroFilterFactoryBean"><br> <property name="securityManager" ref="securityManager"><br> <!-- 如果你的请求,没有认证或者没有认证通过,或者注销之后,都跳转到loginUrl对应的请求中--><br> <property name="loginUrl" value="/s/login.jsp"><br> <!--登录成功之后,跳转到successUrl对应的路径中--><br> <property name="successUrl" value="/s/index"><br><br> <!--没有权限都跳转到unauthorizedUrl对应的路径中--><br> <property name="unauthorizedUrl" value="/s/unauthorized.jsp"><br><br> <!--过滤器链的定义--><br> <property name="filterChainDefinitions"><br>     <value><br>         <!--直接放行不进行拦截--><br>         /s/login.jsp = anon<br>         /login=anon<br>         /logout=logout<br>         /dept/index=perms[“dept:index”]<br>         /dept/save=perms[“dept:save”]<br>         /dept/delete=perms[“dept:delete”]<br>         /dept/update=perms[“dept:update”]<br>         /permission/index=perms[“permission:index”]<br>         <!--
         /*与/**的区别:
                  /* 表示拦截所有的请求,你的请求只能拦截一级,多级无法拦截
                  /**:表示拦截所有的请求,你的请求1级或者多级都可以正常拦截
                authc:认证通过之后才能放行
                anon:匿名过滤器,直接放行
                logout:注销
          --><br>         /** = authc<br>     </value><br> </property><br></property></property></property></property></bean><br></beans></li>
<li>自定义realm</li>
<li>创建MD5工具类</li>
</ol>
</li>
</ol>
<pre><code>3. 集成spring

shiroMD5加密        

    登录时用密码匹配器
</code></pre><h1 id="java操作办公软件：word-ppt-excel-pdf"><a href="#java操作办公软件：word-ppt-excel-pdf" class="headerlink" title="java操作办公软件：word ppt excel pdf"></a>java操作办公软件：word ppt excel pdf</h1><p>easypoi</p>
<h1 id="数据字典"><a href="#数据字典" class="headerlink" title="数据字典"></a>数据字典</h1><p>简单理解就是对表的抽取<br>在真实开发项目中，我们会遇到很多基础表，这些基础表都有一个公共的特性：</p>
<pre><code>1. 字段非常少
2. 数据也非常少
</code></pre><p>使用数据字典的注意事项：</p>
<pre><code>1. 字段必须得少，最多三个字段
2. 如果该表存在，上下级关系也是不能用数据字典
3. 数据量不能过大，最多不超过20个以上
</code></pre><h1 id="图形化界面报表"><a href="#图形化界面报表" class="headerlink" title="图形化界面报表"></a>图形化界面报表</h1><ol>
<li>html5<ol>
<li>优点：占用带宽小，稳定</li>
<li>缺点：兼容性差(IE8以下是不能使用html5)</li>
</ol>
</li>
<li>flash<ol>
<li>优点：市面上基本上所有的浏览器都兼容</li>
<li>缺点：占用带宽大，不稳定<br>专门做图形化界面的插件：</li>
<li>ECharts</li>
<li>HightCharts<h1 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h1><h1 id="发送邮件"><a href="#发送邮件" class="headerlink" title="发送邮件"></a>发送邮件</h1></li>
</ol>
</li>
</ol>
<h1 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h1><h2 id="easyUi分页数据只展示第一页"><a href="#easyUi分页数据只展示第一页" class="headerlink" title="easyUi分页数据只展示第一页"></a>easyUi分页数据只展示第一页</h2><p>query里面加两个方法<br>    public void setPage(Integer page){<br>        this.currentPage=page;<br>    }<br>    public void  setRows(Integer rows){<br>        this.pageSize=rows;<br>    }</p>
<h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><h2 id="登录页面"><a href="#登录页面" class="headerlink" title="登录页面"></a>登录页面</h2><pre><code>1. 登录页面
2. 根据用户名动态显示头像 类似QQ登陆

//实时展示头像
$(function ($) {
    //1.校验用户输入的是正则表达式 先定义正则
    var emailFormat = /^[a-zA-Z0-9]/;
    // var flag = &apos;true&apos;;
    //2.当失去用户焦点的时候校验用户名
    var lastvalue = null;
    $(&apos;#user&apos;).on(&apos;blur&apos;, function () {
        //获取用户输入内容
        var value = $(this).val();
        if (!value || !emailFormat.test(value)) return;
        if (value !== lastvalue) {
            // 接下来需要通过用户名找到对应的头像地址，然后将头像地址改到img的src上
            $.get(&apos;/headImage&apos;, {name: value}, function (res) {
                if (!res) {
                    $(&apos;.avatar&apos;).fadeOut(function () {
                        $(this).on(&apos;load&apos;, function () {
                            $(this).fadeIn()
                        }).attr(&apos;src&apos;, &quot;&quot;);
                    })
                    $(&quot;#spanshow1&quot;).show()
                    $(&quot;#spanshow2&quot;).show()
                    return;
                }
hideSpan()
                $(&apos;.avatar&apos;).fadeOut(function () {
                    $(this).on(&apos;load&apos;, function () {
                        $(this).fadeIn()
                    }).attr(&apos;src&apos;, res);
                })

                // flag = false;
                // $(&apos;.avatar&apos;).fadeOut(function () {
                //   $(this).on(&apos;load&apos;,function () {
                //     $this.fadeIn();
                //   }).attr(&apos;src&apos;, res);
                // })
            })
        }
        lastvalue = value;
    })

})

3. 记住密码cookie

 saveCookie(){ //设置cookie
    var username = $(&quot;#user&quot;).val(); //获取用户名信息
    var password = $(&quot;#passwd&quot;).val(); //获取登陆密码信息
    var  img = $(&quot;#head&quot;).attr(&apos;src&apos;);
    console.debug(111)
    var checked = $(&apos;#brand1&apos;).val()//获取“是否记住密码”复选框
    if(checked==1){ //判断是否选中了“记住密码”复选框
        $.cookie(&quot;username&quot;,username);//调用jquery.cookie.js中的方法设置cookie中的用户名    
        $.cookie(&quot;password&quot;,$.base64.encode(password));//调用jquery.cookie.js中的方法设置cookie中的登陆密码，并使用base64（jquery.base64.js）进行加密    
        $.cookie(&quot;img&quot;,img);//调用jquery.cookie.js中的方法设置cookie中的登陆密码，并使用base64（jquery.base64.js）进行加密    
    }else{
        //$.cookie(&quot;password&quot;, null);
    }
}
function getCookie(){ //获取cookie    
    var username = $.cookie(&quot;username&quot;); //获取cookie中的用户名    
    var password =  $.cookie(&quot;password&quot;); //获取cookie中的登陆密码
    var  img = $.cookie(&quot;img&quot;);
    console.debug(img)
    if(password){//密码存在的话把“记住用户名和密码”复选框勾选住   
        $(&quot;#remberme&quot;).click();
    }
    if(username){//用户名存在的话把用户名填充到用户名文本框    
        $(&quot;#user&quot;).val(username);
    }
    if(password){//密码存在的话把密码填充到密码文本框    
        $(&quot;#passwd&quot;).val($.base64.decode(password));
    }
    if(img){//密码存在的话把密码填充到密码文本框    
        hideSpan()
        $(&quot;#head&quot;).attr(&quot;src&quot;,img)
    }
}
//清除cookie
function clearCookie(name) {
    $.cookie(name, &quot;&quot;, -1);
}
if ($.cookie(&quot;password&quot;)){
    getCookie()
}

4. 提示---display，opacity属性
</code></pre><h2 id="主页"><a href="#主页" class="headerlink" title="主页"></a>主页</h2><pre><code>1. 显示登录用户圆形头像
    .loginUser img{
        width: 50px;
        height: 50px;
        display: flex;
        border-radius: 50%;
        align-items: center;
        justify-content: center;
        overflow: hidden;
    }
2. 拖动标签页
3. 标签页右键菜单
</code></pre><h2 id="标签页面"><a href="#标签页面" class="headerlink" title="标签页面"></a>标签页面</h2><pre><code>1. 添加数据完成时跳到添加数据位置
2. 右键菜单
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/27/（Spring+SpringDataJPA+SpringMVC+EasyUI+Maven)-智能商贸/" data-id="cjzoty7ri000rigtda1q70ugv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-spring" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/24/spring/" class="article-date">
  <time datetime="2019-06-24T01:26:23.757Z" itemprop="datePublished">2019-06-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>title: spring<br>date: 2019-06-24 09:26:23</p>
<h2 id="tags"><a href="#tags" class="headerlink" title="tags:"></a>tags:</h2><h1 id="spring的核心"><a href="#spring的核心" class="headerlink" title="spring的核心"></a>spring的核心</h1><pre><code>1. IOC/DI：IOC指的是控制反转，所谓控制反转指的就是把所有的bean对象，交给spring容器进行管理，由spring统一来创建bean对象，这种创建对象的权利反转就叫做控制反转
2. AOP：面向切面编程，在你指定的service层，执行前或者执行后切一刀，然后织入自己的业务逻辑，能有效的进行解耦
3. AOP有什么作用：
    1. 抽取公共的业务逻辑代码
    2. 扩展功能
    3. 权限
    4. 日志

AOP底层是基于代理模式实现的：
    1. JDK动态代理：前提，你的目标类必须提供了一个接口，否则不能代理
    2. CGLIB动态代理：他可以代理的类，有实现接口，也可以没有实现接口
</code></pre><h1 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h1><h1 id="XML自动注入"><a href="#XML自动注入" class="headerlink" title="XML自动注入"></a>XML自动注入</h1><h1 id="全注解配置"><a href="#全注解配置" class="headerlink" title="全注解配置"></a>全注解配置</h1><p>@Autowired与@Resource的区别</p>
<pre><code>1. 都是注入bean对象
2. @Autowired是spring提供的注解，@Resource是sun公司提供的注解
3. @Autowired注入bean的时候，是先根据类型注入，再根据名字注入
4. 推荐使用@Autowired，@Autowired是spring公司的，与spring无缝衔接
</code></pre><h2 id="spring创建Bean的4中方式"><a href="#spring创建Bean的4中方式" class="headerlink" title="spring创建Bean的4中方式"></a>spring创建Bean的4中方式</h2><pre><code>1. &lt;bean class=&quot;类的全限定名&quot;/&gt;相当于java中的new 类名();
2. 使用FactoryBean来创建 FactoryBean专门创建复杂的对象
    1. 自定义类实现FactoryBean
    2. 复写3个抽象方法
        1. 是否单例
</code></pre><h3 id="BeanFactory和ApplicationContext的区别"><a href="#BeanFactory和ApplicationContext的区别" class="headerlink" title="BeanFactory和ApplicationContext的区别"></a>BeanFactory和ApplicationContext的区别</h3><pre><code>1. BeanFactory它是一个bean工厂，专门负责创建与管理所有的bean对象
2. BeanFactory它是要运行的时候才会去创建Bean对象，而ApplicationContext是BeanFactory的子接口
3. 而ApplicationContext是加载配置文件的时候，就会去创建对应的bean对象，所以以后我们都用ApplicationContext
</code></pre><h1 id="ssj的集成步骤"><a href="#ssj的集成步骤" class="headerlink" title="ssj的集成步骤"></a>ssj的集成步骤</h1><pre><code>1. 创建web项目
2. 导入相应的jar包
3. 配置ApplicationContext.xml文件
    1. 编写jdbc.properties
    2. DataSource
    3. EntityManagerFactory
        1. 依赖dataSource
        2. 扫描domain包
        3. 具体实现的框架
            方言
            是否显示sql
            建表策略
4. springMvc的核心配置
    1. 扫描controller包
    2. 开启springMvc注解支持
    3. 静态资源放行
    4. 视图解析器
5. web.xml
    1. 启动spring容器
    2. 启动springMvc容器
    3. 解决post提交乱码问题
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/24/spring/" data-id="cjzoty7r7000pigtd2oi19id7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-phaser入门" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/21/phaser入门/" class="article-date">
  <time datetime="2019-06-21T11:46:02.000Z" itemprop="datePublished">2019-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/21/phaser入门/">phaser入门</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="phaser介绍"><a href="#phaser介绍" class="headerlink" title="phaser介绍"></a>phaser介绍</h1><p>phaser是一个</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/21/phaser入门/" data-id="cjzoty7r4000kigtdt6hdjo0b" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JPA" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/17/JPA/" class="article-date">
  <time datetime="2019-06-17T01:40:25.000Z" itemprop="datePublished">2019-06-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/17/JPA/">JPA</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="JPA入门"><a href="#JPA入门" class="headerlink" title="JPA入门"></a>JPA入门</h1><p>ORM规范<br>    ORM：对象关系映射<br>作用:操作数据库<br>JPA是持久化规范，hibernate是其中一个实现</p>
<h2 id="JPA对比JDBC的优缺点"><a href="#JPA对比JDBC的优缺点" class="headerlink" title="JPA对比JDBC的优缺点"></a>JPA对比JDBC的优缺点</h2><p>JDBC:优点:</p>
<pre><code>   1. 操作数据库最底层，性能好控制
缺点:
   1. 使用复杂(重复代码太多)
   2. 移植数据库比较麻烦
   3. 如果要实现缓存，要自己手动去实现，性能上面没有相应的控制
   4. JDBC操作sql，jpa操作对象 
</code></pre><p>JPA:优点:</p>
<pre><code>    1. 操作简单
    2. 操作对象就相当于操作数据库
    3. 自带缓存提供
    4. 移植性比较好，只需要换一个方言
缺点:
    1. 不能干预sql语句的生成，性能不好控制 
    2. 如果一个项目对sql比较高，不适合用jpa
    3. 如果一个表中有上亿级别的数据量，不适合用jpa，也不适合用jdbc(架构使用数据库读写分离，分库分表方案解决)
</code></pre><h2 id="连接数据库的配置"><a href="#连接数据库的配置" class="headerlink" title="连接数据库的配置"></a>连接数据库的配置</h2><pre><code>1. 四个基本配置
2. 配置方言
3. shou_sql
    是否显示sql语句
4. 让jpa自动创建相应的表
    hbm2ddl.auto
</code></pre><h2 id="自动建表"><a href="#自动建表" class="headerlink" title="自动建表"></a>自动建表</h2><pre><code>添加注解
    类上
        @Entity
            JPA就知道这里有个对象
        @Table(name=&quot;表名&quot;)
            代表对象与那张表建立关系
            可以不写，表名就是类名
    属性上
        @Id
            主键
            JPA中必须有主键
            JPA要求主键必须是serializable类型
            @GeneratedValue
                主键生成策略
                    主键
                        确定一条数据的唯一性
                            非空且唯一
                    自然主键
                        主键是有意义的
                    用代理主键
                        主键是没有意义的
                            没有意义的数据我们不需要自动填写，自动生成就行了
                                保持唯一性
                IDENTITY
                    自增策略
                        要求
                            主键必需是数字
                            数据库必需支持这个策略
                        性能高
                SEQUENCE
                    序列
                        序列对象
                        看起来还是自增
                        要求
                            主键必需是数字
                            数据库必需支持这个策略
                        性能更高
                AUTO
                    自动区分用的数据库，自动选择使用IDENTITY还是SEQUENCE
                    默认策略
                TABLE
                    表策略
                        兼容所有数据库
                        模拟序列
                        性能稍差
        @ManyToOne
            外键
                告诉JPA这里是个多对一
            fetch：抓取策略
                FetchType.EAGER
                    及时加载
                        默认
                FetchType.LAZY
                    懒(延时)加载，要用时才进行数据加载
            @JoinColum(name=&quot;外键名称&quot;)
                设置外键的名称
                子主题 2
        @Colimn（属性名=别名，length=20，unique=true，nullable=false）
            改别名
            长度改为20
            唯一
            不能为空
        @Transient
            临时属性
                数据库中不要加上
        @Lob
            longtext
        @Temporary
建表策略
    create-drop    
        删除-创建
    create
        删除-创建
    update
        没有表就创建，有表就修改
    validate
        验证你的domin和表是否对应上
</code></pre><h2 id="核心API"><a href="#核心API" class="headerlink" title="核心API"></a>核心API</h2><pre><code>1. Persistence
    持久化对象
    创建EntityManagerFactory对象
2. EntityManagerFactory
    EntityManager工厂对象
    创建EntityManager对象
    特点
        重量级对象
            重
                数据源【连接池】
                二级缓存
                    导jar包
                    配置信息Second-level Cache
                    添加persistence.xml配置信息
                    二级缓存命中
                        同一个EntityManagerFactory，不同EntityManager同一个OID
                    使用场景
                        读取大于配置
                        独享控制权
                        允许出现无效数据
                        数据量不能过大
                所有jpa的配置
                预编译的SQL/JPQL
        这个对象不能随意销毁
            1:1:1--&gt;一个项目：1个EntityManagerFacttory：一个数据库
        这个对象线程安全
            线程安全影响性能
3. EntityManager
    操作数据库（CRUD）
        增删改必须提交事务
    方法
        merge
            添加或者修改
    特点
        轻
            连接对象
            一级缓存
                提高了查询速度
                默认提供
                一级缓存命中
                    同一个EntityManagerFactory，同一个EntityManager同一个OID
        一般来说，一个线程/一次请求 用一次EntityManager
        线程不安全
EntityTransaction
    事务对象（一组操作，要不都成功，要不都失败）
    JPA 增删改一定要有事务
    多个数据库：JTA
</code></pre><h2 id="对象的状态"><a href="#对象的状态" class="headerlink" title="对象的状态"></a>对象的状态</h2><pre><code>1. 四个状态
    1. 临时状态（瞬时状态）
        对象刚刚创建出来还没有与entityManager发生关系
    2. 持久化状态（托管状态）
        对象与entityManager发生关系了
            对象就存在一级缓存中，在一级缓存中的对象也就是持久化对象
        持久化的对象会不会被修改和merge方法没有关系
        只能删除持久化状态的对象
        不能修改OID
    3. 游离状态（脱管状态）
        对象与entityManager解除了关系
            从一级缓存中移除了
    4. 删除状态
        hibernate中没有删除状态
        只要调用了remove方法，这个对象就变成删除状态，JPA就要计划把他删除了
        删除状态是一种特殊的持久化状态
            还在一级缓存中
2. 脏数据更新
    提交数据的时候进行脏数据更新
3. 报错
    n-to-n:持久化对象的OID不能修改
    no session:会话关闭后去拿取数据（懒加载）
</code></pre><h2 id="域对象-domain对象-的关系"><a href="#域对象-domain对象-的关系" class="headerlink" title="域对象(domain对象)的关系"></a>域对象(domain对象)的关系</h2><pre><code>1. 依赖关系
    javabean之间的依赖关系
    分层:表现层,业务层,持久层(依赖关系)
    Controller表现层依赖于Service业务层，Service依赖于Dao持久层
2. 关联关系
    类之间的引用关系，以属性定义的关系表现
    多重性
        一对一
            共享主键
            唯一外键（建议）
            默认迫切加载
        多对一
            有外键关系，外键在哪边，哪边就是多方
            先保存一方在保存多方
                性能高
            默认迫切加载
                改为懒加载
        一对多
            默认懒加载
                集合默认懒加载
        多对多
            中间表
                JoinTable
                    name
                        自定义中间表名字
                    JoinColumns
                        当前类对应的列名
                    inverseJoinColumns
                        对应关系表列名
            集合
                默认懒加载
            双向的多对多
                必须保存表名和列名都是一致的
            子主题 4
    导航性
3. 聚合关系
    双向的多对一，一对多
        让一方放弃关系维护
            两边都在维护
            mappedBy=&quot;多方维护的字段名&quot;
        级联
            cascade=
                CascadeType.PERSIST
                    级联添加
                CascadeType.REMOVE
                    级联删除
                CascadeType.MERGE
                    级联修改
                CascadeType.ALL
                    包含级联增删改
            非常危险的操作，请慎用
                特别是级联删除
            orpherRemove
                孤儿删除
            组合关系一定要用级联
                用最强级联
            凡是单据都是组合关系
4. 组合关系
    强聚合(整体和部分不可分割)
</code></pre><h2 id="hibernate"><a href="#hibernate" class="headerlink" title="hibernate"></a>hibernate</h2><pre><code>操作数据库的框架
    ORM框架
数据库
    关系型数据库
java语言
    面向对象的语言
是jpa的完美实现
</code></pre><h2 id="JPQL"><a href="#JPQL" class="headerlink" title="JPQL"></a>JPQL</h2><pre><code>JPA的查询语言
    面向对象
兼容各种数据库
底层是SQL
使用
    查询结果过滤
        select o from 表名 o where 
    查询排序
        子主题 1
    使用关联对象属性排序
    去重
        distinct
    size
    连接
    jpql关联    黄金法则
            不需要消灭笛卡尔积
            关联的是前面的对象的别名，属性
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/17/JPA/" data-id="cjzoty7qs000bigtdrjlr7lgz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-maven-idea-uml" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/16/maven-idea-uml/" class="article-date">
  <time datetime="2019-06-16T01:15:41.000Z" itemprop="datePublished">2019-06-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/16/maven-idea-uml/">maven&amp;idea&amp;uml</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Maven——一个优秀的项目构建工具"><a href="#Maven——一个优秀的项目构建工具" class="headerlink" title="Maven——一个优秀的项目构建工具"></a>Maven——一个优秀的项目构建工具</h1><p>Maven项目对象模型(pom)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><pre><code>1. 自动构建(mvn jetty:run 清理,编译,测试,部署)
2. 自动导包 pom.xml中配置，先找本地仓库，如果没有，找中央仓库
3. 契约编程(代码更加规范)
</code></pre><h2 id="Maven安装"><a href="#Maven安装" class="headerlink" title="Maven安装"></a>Maven安装</h2><pre><code>1. 在需要安装的路径下解压maven
2. 配置MAVEN_HOME环境
3. 执行mvn命令 生成一个
</code></pre><h2 id="修改默认本地仓库"><a href="#修改默认本地仓库" class="headerlink" title="修改默认本地仓库"></a>修改默认本地仓库</h2><h2 id="maven命令"><a href="#maven命令" class="headerlink" title="maven命令"></a>maven命令</h2><p>mvn compile：编译(有点像javac)<br>mvn clean:清理<br>mvn clean compile:先清理，后编译<br>mvn test:测试(运行几个，失败几个，错误几个)<br>mvn package:打包<br>mvc source:jar:打源码包<br>mvn site：生成一个网站(文档)<br>mvn install:把jar包打好放到本地仓库<br>mvn eclipse:eclipse -&gt; 变成eclipse的结构<br>mvn package -Dmaven.test.skip=true -&gt; 打包的时候跳过测试</p>
<h1 id="IDEA——最好的java开发环境之一"><a href="#IDEA——最好的java开发环境之一" class="headerlink" title="IDEA——最好的java开发环境之一"></a>IDEA——最好的java开发环境之一</h1><h1 id="UML-统一建模语言"><a href="#UML-统一建模语言" class="headerlink" title="UML :统一建模语言"></a>UML :统一建模语言</h1><p>用例图:看权限的图<br>类图:类的关系(继承,多对一，一对多等，组合与聚合关系)<br>流程图:请假流程，开会流程</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/16/maven-idea-uml/" data-id="cjzoty7r7000oigtdvygzsyi2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-EasyUI" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/13/EasyUI/" class="article-date">
  <time datetime="2019-06-13T01:17:12.000Z" itemprop="datePublished">2019-06-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/13/EasyUI/">EasyUI</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="EasyUI的认识"><a href="#EasyUI的认识" class="headerlink" title="EasyUI的认识"></a>EasyUI的认识</h2><ol>
<li>是基于JQuery的ui(界面)插件集合</li>
<li>不需要编写复杂的JavaScript，也不需要对css样式有深入了解，开发者只需要了解一些简单的html标签</li>
<li>学习方式copy+edit<h2 id="EasyUI使用"><a href="#EasyUI使用" class="headerlink" title="EasyUI使用"></a>EasyUI使用</h2></li>
</ol>
<ol>
<li>下载导入easyui文件</li>
<li><p>在对应页面引入easyui的js文件和css文件</p>
<p> &lt;%–引入easyui的样式–%&gt;<br> <link rel="stylesheet" type="text/css" href="js/easyui/themes/default/easyui.css"><br> &lt;%–引入easyui的图标–%&gt;<br> <link rel="stylesheet" type="text/css" href="js/easyui/themes/icon.css"><br> &lt;%–引入jquery的js文件–%&gt;</p>
 <script type="text/javascript" src="js/easyui/jquery.min.js"></script>
 <%--引入easyui的js文件--%>
 <script type="text/javascript" src="js/easyui/jquery.easyui.min.js"></script>
 <%--国际化--%>
 <script type="text/javascript" src="js/easyui/locale/easyui-lang-zh_CN.js"></script>
</%--国际化--%></%--引入easyui的js文件--%></li>
<li><p>使用easyui里面的组件</p>
<ol>
<li><p>直接通过标签来使用<br> 核心添加class=“easyui-组件名”</p>
<p> `&lt;div id=”p” class=”easyui-panel” title=”My Panel”</p>
<pre><code>style=&quot;width:500px;height:150px;padding:10px;background:#fafafa;&quot;
data-options=&quot;iconCls:&apos;icon-save&apos;,closable:true,
collapsible:true,minimizable:true,maximizable:true&quot;&gt;
&lt;p&gt;panel content.&lt;/p&gt;
&lt;p&gt;panel content.&lt;/p&gt;
</code></pre><p> `</p>
</li>
<li><p>通过js创建组件<br><code>&lt;div id=&quot;p&quot; style=&quot;padding:10px;&quot;&gt;
 &lt;p&gt;panel content.&lt;/p&gt;
 &lt;p&gt;panel content.&lt;/p&gt;
&lt;/div&gt;
$(&#39;#p&#39;).panel({
 width:500,
 height:150,
 title:&#39;My Panel&#39;,
 tools:[{
 iconCls:&#39;icon-add&#39;,
 handler:function(){alert(&#39;new&#39;)}
 },{
 iconCls:&#39;icon-save&#39;,
 handler:function(){alert(&#39;save&#39;)}
 }]
});</code></p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2></li>
<li>一般在创建组件的时候，就应该指定好对应属性，不然，如果创建完之后，在修改对应属性，就没有效果</li>
<li>指定属性 在 标签里面指定 ，在js代码在创建的时候，也可以指定；<h2 id="组件三要素"><a href="#组件三要素" class="headerlink" title="组件三要素"></a>组件三要素</h2></li>
</ol>
</li>
</ol>
<ol>
<li>属性:通过标签里面属性，可以让组件展示不同的效果，完成不同的功能<ol>
<li>在组建创建时都有默认属性</li>
<li>属性只能在创建(初始化)组件有效，组件创建完毕后，对某个属性修改无效</li>
<li>属性定义方式<ol>
<li>方式一:直接在标签里面写 属性=属性值</li>
<li>方式二:data-options<br> 注意一:如果在标签里面定义一个属性和在data-options里面定义同一属性，标签里面有效果<br> 注意二:有些属性只能写到data-options里面 想tools这种属性，有多个值，不能放到外面</li>
<li>方式三:直接在js中写</li>
</ol>
</li>
</ol>
</li>
<li>方法:<ol>
<li>调用方法：<br> $(“selector”).组件名(methodName,[params])</li>
<li>创建组件<br> $(“selector”).组件名（{属性键值对}）</li>
</ol>
</li>
<li><p>事件</p>
<p> //点击事件<br> onClick: function(node){</p>
<pre><code>alert(node.text);  // 在用户点击的时候提示
</code></pre><p> },</p>
</li>
</ol>
<h2 id="常用组件"><a href="#常用组件" class="headerlink" title="常用组件"></a>常用组件</h2><ol>
<li>Tabs选项卡</li>
<li>message消息提示框</li>
<li>Form表单</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/13/EasyUI/" data-id="cjzoty7qo0008igtdxtkrewrv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/08/24/java面试题/">java面试题</a>
          </li>
        
          <li>
            <a href="/2019/08/24/B2C商城项目-四/">B2C商城项目(四)</a>
          </li>
        
          <li>
            <a href="/2019/08/21/B2C商城项目-三-商品中心-品牌管理/">B2C商城项目(三)-商品中心-品牌管理</a>
          </li>
        
          <li>
            <a href="/2019/08/19/B2C商城项目(二)/">B2C商城项目(二)</a>
          </li>
        
          <li>
            <a href="/2019/08/18/B2C商城项目(一)/">B2C商城项目(一)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 sunlei<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>